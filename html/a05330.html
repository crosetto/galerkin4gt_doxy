<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Galerkin4GT: Scalar Vector Sum</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Galerkin4GT
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">Contributive effort to implement proof-of-concept Galerkin methods on new HPC architectures</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a05330.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Scalar Vector Sum </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is the first and easiest example of usage of Galerkin4GT and GridTools libraries API, in particular in the context of Galerkin problem solution. In this example we will provide a lot of general basic information that will be common to all the other examples. Therefore, always refer to this page if you get lost at some point in the advanced examples, you could find the missing information here.</p>
<p>In this example we will demonstrate how to compute the sum of between a vector and a scalar constant making use of Galerkin4GT and GridTools API. The considered operation corresponds to the sum of all "a" vector elements with a common constant factor "c" as in the following equation:</p>
<div class="fragment"><div class="line">c+[a_{1},a_{2},a_{3},...,a_{N}]=[c+a_{1},c+a_{2},c+a_{3},...,c+a_{N}]</div></div><!-- fragment --><p>Let's start with a discussion concerning how vectors are seen in this context and with reference to the solution of Galerkin problems. In real cases we will deal with meshes of elements, dofs and source terms just to name some of the involved mathematical entities. As usual, when switching from a mathematical formulation to a numerical implementation, there will be a multidimensional array representing the source term all over the mesh. Particularly, for each mesh element, this array shall contain the source value for each dof: the array elements will be therefore univoquely identified by 4 indexes, the first three indexes being the mesh element position in a cartesian reference frame and the fourth one being the dof. It follows that the total size of this kind of array is equal to the number of mesh elements times the number of dof per element. This general storage structure, with its correspondence between storage elements and mesh elements, dofs, etc..., is used also for other kind of storages with larger dimensionality like the mass or stiffness matrix. We will introduce them in the other more complex examples.</p>
<p>With the above structure in mind, operations like matrix-vector multiplications, matrix/vector assembly, etc... that are common in Galerkin problem solution can be interpreted as stencil operations in GridTools context, with the possibility of exploiting the available GridTools API.</p>
<p>Let's move to the implementation of this first example.</p>
<p>We start by defining the problem sizes in the following snippet: </p><div class="fragment"><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d1=5;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d2=5;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d3=5;</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_rows(10);</div></div><!-- fragment --><p> where d1, d2 and d3 are the mesh sizes in the three space dimensions and where n_rows would correspond to the number of dofs of each mesh element. We then instantiate the scalar constant and arrays as follows </p><div class="fragment"><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    <span class="comment">// scalar a</span></div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    <a class="code" href="a03854.html">scalar</a> s_a(23.);</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    <span class="keyword">auto</span> s_a_ = gdl::gt::make_global_parameter(s_a);</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    <span class="comment">// vector b</span></div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    <span class="keyword">using</span> vector_b_storage_info_t=gdl::storage_info&lt; __COUNTER__, gdl::layout_tt&lt;4&gt; &gt;;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    <span class="keyword">using</span> vector_b_type=gdl::storage_t&lt; vector_b_storage_info_t &gt;;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    vector_b_storage_info_t v_b_(d1,d2,d3,n_rows);</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    vector_b_type v_b(v_b_, 1.e0, <span class="stringliteral">&quot;v_b&quot;</span>);</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    <span class="comment">// vector out</span></div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    <span class="keyword">using</span> vector_out_storage_info_t=gdl::storage_info&lt; __COUNTER__, gdl::layout_tt&lt;4&gt; &gt;;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    <span class="keyword">using</span> vector_out_type=gdl::storage_t&lt; vector_out_storage_info_t &gt;;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    vector_out_storage_info_t v_out_(d1,d2,d3,n_rows);</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    vector_out_type v_out(v_out_, 0.e0, <span class="stringliteral">&quot;v_out&quot;</span>);</div><div class="ttc" id="a03854_html"><div class="ttname"><a href="a03854.html">scalar</a></div><div class="ttdoc">[scalar_struct] </div><div class="ttdef"><b>Definition:</b> scalvec.cpp:55</div></div>
</div><!-- fragment --><p> Let's start talking about the instantiation of tensor-like objects, in our case the <code>v_b</code> and <code>v_out</code> arrays: </p><div class="fragment"><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    <span class="comment">// vector b</span></div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    <span class="keyword">using</span> vector_b_storage_info_t=gdl::storage_info&lt; __COUNTER__, gdl::layout_tt&lt;4&gt; &gt;;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    <span class="keyword">using</span> vector_b_type=gdl::storage_t&lt; vector_b_storage_info_t &gt;;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    vector_b_storage_info_t v_b_(d1,d2,d3,n_rows);</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    vector_b_type v_b(v_b_, 1.e0, <span class="stringliteral">&quot;v_b&quot;</span>);</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    <span class="comment">// vector out</span></div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    <span class="keyword">using</span> vector_out_storage_info_t=gdl::storage_info&lt; __COUNTER__, gdl::layout_tt&lt;4&gt; &gt;;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    <span class="keyword">using</span> vector_out_type=gdl::storage_t&lt; vector_out_storage_info_t &gt;;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    vector_out_storage_info_t v_out_(d1,d2,d3,n_rows);</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    vector_out_type v_out(v_out_, 0.e0, <span class="stringliteral">&quot;v_out&quot;</span>);</div></div><!-- fragment --><p> The instantiation of each storage object must be performed using the GridTools API and it requires two elements: a storage_info object, providing the shape and size of the storage, and a storage_t object representing the real storage variable.</p>
<p>The shape of the storage includes its cardinality and the ordering in memory of its elements with respect to their indexes and is described in the form of a layout_tt type in the storage_info template parameter list. The storage dimensions, that must match the defined storage cardinality, are instead provided as input parameters to the constructor of the storage_info type itself. In particular, the two vectors <code>v_b</code> and <code>v_out</code> are declared as 4D tensors. Their sizes correspond to the problem dimensions introduced in the first snippet. For more information about storage layout have a look to the GridTools documentation. The instantiated storage_info object is then provided to the constructor of storage_t type.</p>
<p>The scalar constant that we use in this example is defined using a different type: we could use a 4D storage also in this case for our stencil operation assigning to all the array elements the same value but of course this would be waste of resources. GridTools provides a specific way to use constant values of this kind by means of the so called global_parameter type. Let's have a look to the scalar constant instantiation snippet: </p><div class="fragment"><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    <span class="comment">// scalar a</span></div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    <a class="code" href="a03854.html">scalar</a> s_a(23.);</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    <span class="keyword">auto</span> s_a_ = gdl::gt::make_global_parameter(s_a);</div><div class="ttc" id="a03854_html"><div class="ttname"><a href="a03854.html">scalar</a></div><div class="ttdoc">[scalar_struct] </div><div class="ttdef"><b>Definition:</b> scalvec.cpp:55</div></div>
</div><!-- fragment --><p> As it can be seen we start by defining the <code>s_a</code> scalar variable of <a class="el" href="a03854.html">scalar</a> type defined as </p><div class="fragment"><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;<span class="keyword">struct </span><a class="code" href="a03854.html">scalar</a> {</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;  gdl::gt::float_type m_value;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;  <a class="code" href="a03854.html">scalar</a>(gdl::gt::float_type i_val) : m_value(i_val) {}</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;  GT_FUNCTION</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;  gdl::gt::float_type get_value()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_value; }</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;};</div><div class="ttc" id="a03854_html"><div class="ttname"><a href="a03854.html">scalar</a></div><div class="ttdoc">[scalar_struct] </div><div class="ttdef"><b>Definition:</b> scalvec.cpp:55</div></div>
</div><!-- fragment --><p> This is basically a wrapper around a floating point type (have a look to TODO:link file for Galerkin4GT type definitions) providing a get_value method which returns the stored scalar value. This method is "labelled" with the GT_FUNCTION macro: detailed information can be found in GridTools documentation (TODO:link) in our case it is enough to know that this will give us the possibility to call the above method within the computational steps defined according to GridTools framework (We will be back on this in the lines that follows). Given the s_a variable we then instantiate a new variables s_a_ which plays a similar role of the storage_info type previously discussed for the array case. As it can be seen we do that using GridTools make_global_parameter function.</p>
<p>The subsequent step in this example is the definition of the size of the computational domain from a GridTools point of view: this corresponds in our case to the set of mesh elements that will be included in the computation. Particularly, we do this by instantiating a gridtools::grid&lt;axis&gt; object and providing the computational domain sizes as in the following snippet: </p><div class="fragment"><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    <span class="keyword">auto</span> grid=gridtools::grid&lt;axis&gt;({0, 0, 0, d1-1, d1},</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;                                         {0, 0, 0, d2-1, d2});</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    grid.value_list[0] = 0;</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    grid.value_list[1] = d3-1;</div></div><!-- fragment --><p>Have a look to GridTools documentation (TODO:add ref) for more details.</p>
<p>Together with the computational domain size defined in the previous step, GridTools frameworks expects us to define the set of data structure variables that will be involved in the various stencil steps. Basically this corresponds to decle the list of storages that will be provided as input/output parameters of our computations. This is what we do in the following snippet: </p><div class="fragment"><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    <span class="keyword">typedef</span> gdl::gt::arg&lt;0, decltype(s_a_) &gt; p_s_a;</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    GRIDTOOLS_STATIC_ASSERT(gdl::gt::is_global_parameter&lt; decltype(s_a_) &gt;::value, <span class="stringliteral">&quot;is_global_parameter check failed&quot;</span>);</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    <span class="keyword">typedef</span> gdl::gt::arg&lt;1,vector_b_type&gt; p_v_b;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    <span class="keyword">typedef</span> gdl::gt::arg&lt;2,vector_out_type&gt; p_v_out;</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;    <span class="keyword">typedef</span> boost::mpl::vector&lt;p_s_a, p_v_b, p_v_out&gt; accessor_list;</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;    ::gridtools::aggregator_type&lt;accessor_list&gt; domain(boost::fusion::make_vector(&amp;s_a_, &amp;v_b, &amp;v_out));</div></div><!-- fragment --><p>What we are doing in the above code block is defining a set of placeholder types p_s_a, p_v_b and p_v_out and a placeholder list type accessor_list, containing the placeholders themselves. The defined accessor_list type is then provided as template parameter for the instantiation of an aggregator_type variable domain. The correspondence between the order of placeholders in the accessor_list parameter list, the order of the storages referred by the pointers provided in input to the make_vector function and the integer template parameter defining the placeholder type is fundamental.</p>
<p>We are now ready to setup our calculation. To do that we define a computation tree object using the make_computation function as in the following snippet: </p><div class="fragment"><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;    <span class="keyword">auto</span> compute_sum=::gridtools::make_computation&lt;BACKEND&gt;(domain,</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;                                                      grid,</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;                                                      gridtools::make_multistage(gridtools::enumtype::execute&lt;gridtools::enumtype::forward&gt;(),</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;                                                                                 gridtools::make_stage&lt; <a class="code" href="a04014.html">gdl::functors::scalvec</a>&lt;4,<a class="code" href="a04002.html">gdl::functors::sum_operator&lt;float_t&gt;</a> &gt; &gt;(p_s_a(),p_v_b(),p_v_out())</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;                                                                                 )</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;                                                     );</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    compute_sum-&gt;ready();</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    compute_sum-&gt;steady();</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    compute_sum-&gt;run();</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    compute_sum-&gt;finalize();</div><div class="ttc" id="a04002_html"><div class="ttname"><a href="a04002.html">gdl::functors::sum_operator</a></div><div class="ttdef"><b>Definition:</b> matvec.hpp:56</div></div>
<div class="ttc" id="a04014_html"><div class="ttname"><a href="a04014.html">gdl::functors::scalvec</a></div><div class="ttdef"><b>Definition:</b> matvec.hpp:85</div></div>
</div><!-- fragment --><p>The compute_sum variable represents our scalar plus array calculation over all array elements which, however, has not been performed yet. In fact, the information provided to the make_computation are processed at compile time to produce the actual algorithm to be run on the specific backend provided as template parameter (BACKEND). This step only defines the computation, which is then lazily executed in the subsequent steps. The specific computation tree is defined by the list of provided computation stages, returned by the make_stage function, and provided in input to make_multistage. In our example we have just one stage, corresponding to the calculation of the scalar array elementwise sum: this is specified in the code by providing the relative functor as template parameter to the make_stage function. The input parameter list of this function corresponds to the input list of the functor itself. In this example we use just one functor (scalvec) which provides a generic implementation for elementwise operations on scalar-multidimensional tensor pairs (we will have a look to the functor implementation at the end of this page).</p>
<p>The subsequent steps, corresponding to the calls to the ready, steady, run, and  methods, performs the real computation.</p>
<p>Finally we perform a check of the computed results.</p>
<p>Let's have a look to the functor provided in the definition of the stencil considered in this example: </p><div class="fragment"><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;        <span class="comment">// TODO: these element by element operations could be parallelized avoiding the functor loop</span></div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;        <span class="comment">// Vector-wise z = x op y where y is a scalar and x and z vectors of the same size</span></div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;        <span class="keyword">template</span> &lt;u<span class="keywordtype">short</span>_t Dim, <span class="keyword">class</span> Operator&gt;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;        <span class="keyword">struct </span>scalvec;</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;        <span class="keyword">template</span> &lt;<span class="keyword">class</span> Operator&gt;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;        <span class="keyword">struct </span>scalvec&lt;4, Operator&gt; {</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;            <span class="comment">// [arguments]</span></div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;            <span class="keyword">using</span> in1=gt::global_accessor&lt;0, enumtype::in&gt; ;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;            <span class="keyword">using</span> in2=gt::accessor&lt;1, enumtype::in, gt::extent&lt;&gt; , 4&gt;;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;            <span class="keyword">using</span> out=gt::accessor&lt;2, enumtype::inout, gt::extent&lt;&gt; , 4&gt; ;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;            <span class="keyword">using</span> arg_list=boost::mpl::vector&lt; in1, in2, out &gt; ;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;            <span class="comment">// [arguments]</span></div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;            <span class="comment">// [do_method]</span></div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;            <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Evaluation&gt;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;            GT_FUNCTION</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;            <span class="keyword">static</span> <span class="keywordtype">void</span> Do(Evaluation <span class="keyword">const</span> &amp; eval, x_interval) {</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;                gt::dimension&lt;4&gt; row;</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;                <a class="code" href="a04709.html">uint_t</a> <span class="keyword">const</span> num_rows=eval.template get_storage_dim&lt;3&gt;(in2());</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;                <span class="comment">// Loop over vector elements</span></div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;                <span class="keywordflow">for</span>(<a class="code" href="a04709.html">uint_t</a> i=0;i&lt;num_rows;++i){</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;                    eval(out(row+i)) = Operator::eval(eval(in1()).get_value(),eval(in2(row+i)));</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;                }</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;            }</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;            <span class="comment">// [do_method]</span></div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;        };</div><div class="ttc" id="a04709_html"><div class="ttname"><a href="a04709.html">uint_t</a></div></div>
</div><!-- fragment --><p>Functors like this are the way stencil operations must be implemented in GridTools: they must define the set of input and output argument types of the implemented computation </p><div class="fragment"><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;            <span class="keyword">using</span> in1=gt::global_accessor&lt;0, enumtype::in&gt; ;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;            <span class="keyword">using</span> in2=gt::accessor&lt;1, enumtype::in, gt::extent&lt;&gt; , 4&gt;;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;            <span class="keyword">using</span> out=gt::accessor&lt;2, enumtype::inout, gt::extent&lt;&gt; , 4&gt; ;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;            <span class="keyword">using</span> arg_list=boost::mpl::vector&lt; in1, in2, out &gt; ;</div></div><!-- fragment --><p>and provide a Do method implementing the computation itself </p><div class="fragment"><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;            <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Evaluation&gt;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;            GT_FUNCTION</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;            <span class="keyword">static</span> <span class="keywordtype">void</span> Do(Evaluation <span class="keyword">const</span> &amp; eval, x_interval) {</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;                gt::dimension&lt;4&gt; row;</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;                <a class="code" href="a04709.html">uint_t</a> <span class="keyword">const</span> num_rows=eval.template get_storage_dim&lt;3&gt;(in2());</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;                <span class="comment">// Loop over vector elements</span></div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;                <span class="keywordflow">for</span>(<a class="code" href="a04709.html">uint_t</a> i=0;i&lt;num_rows;++i){</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;                    eval(out(row+i)) = Operator::eval(eval(in1()).get_value(),eval(in2(row+i)));</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;                }</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;            }</div><div class="ttc" id="a04709_html"><div class="ttname"><a href="a04709.html">uint_t</a></div></div>
</div><!-- fragment --><p>We will not give many details concerning functors implementation since they are provided in GridTools documentation (TODO: link) and we will only discuss those information that are relevant for our application. Particularly, it is interesting in this case looking at the way the argument types are defined: each argument is a so called accessor type. In our case the stencil arguments are one input global parameter (the constant) and two storages (the arrays) which are an input and input-output parameter respectively. This is reflected in the types defined by this functors which are a global_accessor and an accessor both with input intent (enumtype::in) and an accessors with input-output intent (enumtype::inout). The first template parameter provided to these accessor/global_accessors defines the correspondence between these types and the functor input parameter order as defined in our example main source code. The last template parameter provided to the two accessor types corresponds instead to the number of storage dimensions and of course this parameter is not present in the definition of the global_accessor type.</p>
<p>Another interesting element of this functor is represented by the call to the get_storage_dim template function, which is quite common in Galerkin4GT stencils: this function returns the size of the storage corresponding to accessor provided in input to the function itself along the direction specified as template parameter. In our case the value returned by the function is the size of the v_a storage defined in our main function along is fourth dimension, namely the number of dofs.</p>
<p>Finally, it must be noted that this specific functor has two template parameters: the first one is the number of dimensions of the tensors and the second one the operator to be used for the elementwise operation. These operators must be implemented as functor providing the eval method as in the library provided operators of the following snippet: </p><div class="fragment"><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;        <span class="keyword">struct </span>sum_operator {</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;            GT_FUNCTION</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;            <span class="keyword">static</span> T eval(T <span class="keyword">const</span> &amp; i_a, T <span class="keyword">const</span> &amp; i_b) { <span class="keywordflow">return</span> i_a+i_b; }</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        };</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;        <span class="keyword">struct </span>sub_operator {</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;            GT_FUNCTION</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;            <span class="keyword">static</span> T eval(T <span class="keyword">const</span> &amp; i_a, T <span class="keyword">const</span> &amp; i_b) { <span class="keywordflow">return</span> i_a-i_b; }</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;        };</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;        <span class="keyword">struct </span>mult_operator {</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;            GT_FUNCTION</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;            <span class="keyword">static</span> T eval(T <span class="keyword">const</span> &amp; i_a, T <span class="keyword">const</span> &amp; i_b) { <span class="keywordflow">return</span> i_a*i_b; }</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;        };</div></div><!-- fragment --> <h1>Full Code </h1>
<div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">  GridTools Libraries</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  Copyright (c) 2016, GridTools Consortium</span></div><div class="line"><span class="comment">  All rights reserved.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  Redistribution and use in source and binary forms, with or without</span></div><div class="line"><span class="comment">  modification, are permitted provided that the following conditions are</span></div><div class="line"><span class="comment">  met:</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  1. Redistributions of source code must retain the above copyright</span></div><div class="line"><span class="comment">  notice, this list of conditions and the following disclaimer.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  2. Redistributions in binary form must reproduce the above copyright</span></div><div class="line"><span class="comment">  notice, this list of conditions and the following disclaimer in the</span></div><div class="line"><span class="comment">  documentation and/or other materials provided with the distribution.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  3. Neither the name of the copyright holder nor the names of its</span></div><div class="line"><span class="comment">  contributors may be used to endorse or promote products derived from</span></div><div class="line"><span class="comment">  this software without specific prior written permission.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span></div><div class="line"><span class="comment">  &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span></div><div class="line"><span class="comment">  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span></div><div class="line"><span class="comment">  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span></div><div class="line"><span class="comment">  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span></div><div class="line"><span class="comment">  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span></div><div class="line"><span class="comment">  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span></div><div class="line"><span class="comment">  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span></div><div class="line"><span class="comment">  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span></div><div class="line"><span class="comment">  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span></div><div class="line"><span class="comment">  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  For information: http://eth-cscs.github.io/gridtools/</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="preprocessor">#pragma once</span></div><div class="line"></div><div class="line"><span class="comment">// TODO: we need an specific header for storage type definition to avoid the include that follows</span></div><div class="line"><span class="preprocessor">#include &quot;../numerics/basis_functions.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;stencil-composition/expressions/expressions.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../galerkin_defs.hpp&quot;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="a03201.html">gdl</a>{</div><div class="line"></div><div class="line">    <span class="keyword">using namespace </span><a class="code" href="a03211.html">gt::expressions</a>;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">namespace </span><a class="code" href="a03209.html">functors</a>{</div><div class="line"></div><div class="line">        <span class="comment">// TODO: shall we move the interval definition in one of the galerkin definition headers?</span></div><div class="line">        <span class="keyword">typedef</span> gridtools::interval&lt;gridtools::level&lt;0,-1&gt;, gridtools::level&lt;1,-1&gt; &gt; x_interval;</div><div class="line"></div><div class="line">        <span class="comment">// [vec_binary_operators]</span></div><div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">        <span class="keyword">struct </span>sum_operator {</div><div class="line"></div><div class="line">            GT_FUNCTION</div><div class="line">            <span class="keyword">static</span> T eval(T <span class="keyword">const</span> &amp; i_a, T <span class="keyword">const</span> &amp; i_b) { <span class="keywordflow">return</span> i_a+i_b; }</div><div class="line"></div><div class="line">        };</div><div class="line"></div><div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">        <span class="keyword">struct </span>sub_operator {</div><div class="line"></div><div class="line">            GT_FUNCTION</div><div class="line">            <span class="keyword">static</span> T eval(T <span class="keyword">const</span> &amp; i_a, T <span class="keyword">const</span> &amp; i_b) { <span class="keywordflow">return</span> i_a-i_b; }</div><div class="line"></div><div class="line">        };</div><div class="line"></div><div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">        <span class="keyword">struct </span>mult_operator {</div><div class="line"></div><div class="line">            GT_FUNCTION</div><div class="line">            <span class="keyword">static</span> T eval(T <span class="keyword">const</span> &amp; i_a, T <span class="keyword">const</span> &amp; i_b) { <span class="keywordflow">return</span> i_a*i_b; }</div><div class="line"></div><div class="line">        };</div><div class="line">        <span class="comment">// [vec_binary_operators]</span></div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">// [scalvec]</span></div><div class="line">        <span class="comment">// TODO: these element by element operations could be parallelized avoiding the functor loop</span></div><div class="line">        <span class="comment">// Vector-wise z = x op y where y is a scalar and x and z vectors of the same size</span></div><div class="line">        <span class="keyword">template</span> &lt;u<span class="keywordtype">short</span>_t Dim, <span class="keyword">class</span> Operator&gt;</div><div class="line">        <span class="keyword">struct </span>scalvec;</div><div class="line"></div><div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">class</span> Operator&gt;</div><div class="line">        <span class="keyword">struct </span>scalvec&lt;4, Operator&gt; {</div><div class="line"></div><div class="line">            <span class="comment">// [arguments]</span></div><div class="line">            <span class="keyword">using</span> in1=gt::global_accessor&lt;0, enumtype::in&gt; ;</div><div class="line">            <span class="keyword">using</span> in2=gt::accessor&lt;1, enumtype::in, gt::extent&lt;&gt; , 4&gt;;</div><div class="line">            <span class="keyword">using</span> out=gt::accessor&lt;2, enumtype::inout, gt::extent&lt;&gt; , 4&gt; ;</div><div class="line">            <span class="keyword">using</span> arg_list=boost::mpl::vector&lt; in1, in2, out &gt; ;</div><div class="line">            <span class="comment">// [arguments]</span></div><div class="line"></div><div class="line">            <span class="comment">// [do_method]</span></div><div class="line">            <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Evaluation&gt;</div><div class="line">            GT_FUNCTION</div><div class="line">            <span class="keyword">static</span> <span class="keywordtype">void</span> Do(Evaluation <span class="keyword">const</span> &amp; eval, x_interval) {</div><div class="line">                gt::dimension&lt;4&gt; row;</div><div class="line">                uint_t <span class="keyword">const</span> num_rows=eval.template get_storage_dim&lt;3&gt;(in2());</div><div class="line"></div><div class="line">                <span class="comment">// Loop over vector elements</span></div><div class="line">                <span class="keywordflow">for</span>(uint_t i=0;i&lt;num_rows;++i){</div><div class="line">                    eval(out(row+i)) = Operator::eval(eval(in1()).get_value(),eval(in2(row+i)));</div><div class="line">                }</div><div class="line">            }</div><div class="line">            <span class="comment">// [do_method]</span></div><div class="line">        };</div><div class="line">        <span class="comment">// [scalvec]</span></div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">// [vecvec]</span></div><div class="line">        <span class="comment">// TODO: these element by element operations could be parallelized avoiding the functor loop</span></div><div class="line">        <span class="comment">// Element-wise z = x op y where x, y and z are vectors of the same size</span></div><div class="line">        <span class="keyword">template</span> &lt;u<span class="keywordtype">short</span>_t Dim, <span class="keyword">class</span> Operator&gt;</div><div class="line">        <span class="keyword">struct </span>vecvec;</div><div class="line"></div><div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">class</span> Operator&gt;</div><div class="line">        <span class="keyword">struct </span>vecvec&lt;4, Operator&gt; {</div><div class="line"></div><div class="line">            <span class="keyword">using</span> in1=gt::accessor&lt;0, enumtype::in, gt::extent&lt;&gt; , 4&gt; ;</div><div class="line">            <span class="keyword">using</span> in2=gt::accessor&lt;1, enumtype::in, gt::extent&lt;&gt; , 4&gt; ;</div><div class="line">            <span class="keyword">using</span> out=gt::accessor&lt;2, enumtype::inout, gt::extent&lt;&gt; , 4&gt; ;</div><div class="line">            <span class="keyword">using</span> arg_list=boost::mpl::vector&lt; in1, in2, out &gt; ;</div><div class="line"></div><div class="line">            <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Evaluation&gt;</div><div class="line">            GT_FUNCTION</div><div class="line">            <span class="keyword">static</span> <span class="keywordtype">void</span> Do(Evaluation <span class="keyword">const</span> &amp; eval, x_interval) {</div><div class="line">                gt::dimension&lt;4&gt; row;</div><div class="line">                uint_t <span class="keyword">const</span> num_rows=eval.template get_storage_dim&lt;3&gt;(in1());</div><div class="line"></div><div class="line">                <span class="comment">// Loop over vector elements</span></div><div class="line">                <span class="keywordflow">for</span>(uint_t i=0;i&lt;num_rows;++i){</div><div class="line">                    eval(out(row+i)) = Operator::eval(eval(in1(row+i)),eval(in2(row+i)));</div><div class="line">                }</div><div class="line">            }</div><div class="line">        };</div><div class="line"></div><div class="line">        <span class="comment">// TODO: rename these operators, their are working on multiindex object in general</span></div><div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">class</span> Operator&gt;</div><div class="line">        <span class="keyword">struct </span>vecvec&lt;5, Operator&gt; {</div><div class="line"></div><div class="line">            <span class="keyword">using</span> in1=gt::accessor&lt;0, enumtype::in, gt::extent&lt;&gt; , 5&gt; ;</div><div class="line">            <span class="keyword">using</span> in2=gt::accessor&lt;1, enumtype::in, gt::extent&lt;&gt; , 5&gt; ;</div><div class="line">            <span class="keyword">using</span> out=gt::accessor&lt;2, enumtype::inout, gt::extent&lt;&gt; , 5&gt; ;</div><div class="line">            <span class="keyword">using</span> arg_list=boost::mpl::vector&lt; in1, in2, out &gt; ;</div><div class="line"></div><div class="line">            <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Evaluation&gt;</div><div class="line">            GT_FUNCTION</div><div class="line">            <span class="keyword">static</span> <span class="keywordtype">void</span> Do(Evaluation <span class="keyword">const</span> &amp; eval, x_interval) {</div><div class="line">                gt::dimension&lt;4&gt; row;</div><div class="line">                gt::dimension&lt;5&gt; col;</div><div class="line">                uint_t <span class="keyword">const</span> num_rows=eval.template get_storage_dim&lt;3&gt;(in1());</div><div class="line">                uint_t <span class="keyword">const</span> num_cols=eval.template get_storage_dim&lt;4&gt;(in1());</div><div class="line"></div><div class="line">                <span class="comment">// Loop over vector elements</span></div><div class="line">                <span class="keywordflow">for</span>(uint_t i=0;i&lt;num_rows;++i)</div><div class="line">                    <span class="keywordflow">for</span>(uint_t j=0;j&lt;num_cols;++j)  {</div><div class="line">                        eval(out(row+i,col+j)) = Operator::eval(eval(in1(row+i,col+j)),eval(in2(row+i,col+j)));</div><div class="line">                }</div><div class="line">            }</div><div class="line">        };</div><div class="line"></div><div class="line">        <span class="comment">// [vecvec]</span></div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">// [matvec]</span></div><div class="line">        <span class="comment">// left-multiply b = b + A x</span></div><div class="line">        <span class="keyword">struct </span>matvec {</div><div class="line"></div><div class="line">            <span class="keyword">using</span> in1=gt::accessor&lt;0, enumtype::in, gt::extent&lt;&gt; , 5&gt; <span class="keyword">const</span>;</div><div class="line">            <span class="keyword">using</span> in2=gt::accessor&lt;1, enumtype::in, gt::extent&lt;&gt; , 4&gt; <span class="keyword">const</span>;</div><div class="line">            <span class="keyword">using</span> out=gt::accessor&lt;2, enumtype::inout, gt::extent&lt;&gt; , 4&gt; ;</div><div class="line">            <span class="keyword">using</span> arg_list=boost::mpl::vector&lt; in1, in2, out &gt; ;</div><div class="line"></div><div class="line">            <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Evaluation&gt;</div><div class="line">            GT_FUNCTION</div><div class="line">            <span class="keyword">static</span> <span class="keywordtype">void</span> Do(Evaluation <span class="keyword">const</span> &amp; eval, x_interval) {</div><div class="line">                gt::dimension&lt;4&gt; row;</div><div class="line">                gt::dimension&lt;5&gt; col;</div><div class="line">                uint_t <span class="keyword">const</span> cardinality_i=eval.template get_storage_dim&lt;3&gt;(in1());</div><div class="line">                uint_t <span class="keyword">const</span> cardinality_j=eval.template get_storage_dim&lt;4&gt;(in1());</div><div class="line">                <span class="comment">//for all dofs in a boundary face</span></div><div class="line">                <span class="keywordflow">for</span>(short_t I=0; I&lt;cardinality_i; I++)</div><div class="line">                {</div><div class="line">                    <span class="keywordflow">for</span>(short_t J=0; J&lt;cardinality_j; J++)</div><div class="line">                    {</div><div class="line">                        eval(out(row+I)) += eval(in1(row+I, col+J)*in2(row+J));</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        };</div><div class="line">        <span class="comment">// [matvec]</span></div><div class="line"></div><div class="line">        <span class="comment">// [matvec_bd]</span></div><div class="line">        <span class="keyword">struct </span>matvec_VolxBdxVol {</div><div class="line"></div><div class="line">            <span class="keyword">using</span> in1=gt::accessor&lt;0, enumtype::in, gt::extent&lt;&gt; , 4&gt; <span class="keyword">const</span>;</div><div class="line">            <span class="keyword">using</span> in2=gt::accessor&lt;1, enumtype::in, gt::extent&lt;&gt; , 6&gt; <span class="keyword">const</span>;</div><div class="line">            <span class="keyword">using</span> out=gt::accessor&lt;2, enumtype::inout, gt::extent&lt;&gt; , 4&gt; ;</div><div class="line">            <span class="keyword">using</span> arg_list=boost::mpl::vector&lt; in1, in2, out &gt; ;</div><div class="line"></div><div class="line">            <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Evaluation&gt;</div><div class="line">            GT_FUNCTION</div><div class="line">            <span class="keyword">static</span> <span class="keywordtype">void</span> Do(Evaluation <span class="keyword">const</span> &amp; eval, x_interval) {</div><div class="line">                gt::dimension&lt;4&gt; row;</div><div class="line">                gt::dimension&lt;5&gt; col;</div><div class="line">                gt::dimension&lt;6&gt; face;</div><div class="line"></div><div class="line">                uint_t <span class="keyword">const</span> cardinality_i=eval.template get_storage_dim&lt;3&gt;(in2());</div><div class="line">                uint_t <span class="keyword">const</span> cardinality_j=eval.template get_storage_dim&lt;4&gt;(in2());</div><div class="line">                uint_t <span class="keyword">const</span> faces_=eval.template get_storage_dim&lt;5&gt;(in2());</div><div class="line"></div><div class="line">                <span class="comment">//for all dofs in a boundary face</span></div><div class="line">                <span class="keywordflow">for</span>(short_t I=0; I&lt;cardinality_i; I++)</div><div class="line">                    <span class="keywordflow">for</span>(short_t J=0; J&lt;cardinality_j; J++)</div><div class="line">                        <span class="keywordflow">for</span>(short_t K=0; K&lt;faces_; K++)</div><div class="line">                        {</div><div class="line">                            eval(out(row+I)) += eval(in2(row+I, col+J, face+K)*in1(row+J));</div><div class="line">                        }</div><div class="line">            }</div><div class="line">        };</div><div class="line">        <span class="comment">// [matvec_bd]</span></div><div class="line"></div><div class="line">        <span class="comment">// [matvec_bd]</span></div><div class="line">        <span class="keyword">struct </span>matvec_BdxBdxBd {</div><div class="line"></div><div class="line">            <span class="keyword">using</span> in1=gt::accessor&lt;0, enumtype::in, gt::extent&lt;&gt; , 5&gt; <span class="keyword">const</span>;</div><div class="line">            <span class="keyword">using</span> in2=gt::accessor&lt;1, enumtype::in, gt::extent&lt;&gt; , 6&gt; <span class="keyword">const</span>;</div><div class="line">            <span class="keyword">using</span> out=gt::accessor&lt;2, enumtype::inout, gt::extent&lt;&gt; , 5&gt; ;</div><div class="line">            <span class="keyword">using</span> arg_list=boost::mpl::vector&lt; in1, in2,  out &gt; ;</div><div class="line"></div><div class="line">            <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Evaluation&gt;</div><div class="line">            GT_FUNCTION</div><div class="line">            <span class="keyword">static</span> <span class="keywordtype">void</span> Do(Evaluation <span class="keyword">const</span> &amp; eval, x_interval) {</div><div class="line">                gt::dimension&lt;4&gt; row;</div><div class="line">                gt::dimension&lt;5&gt; col;</div><div class="line">                gt::dimension&lt;6&gt; face;</div><div class="line"></div><div class="line">                uint_t <span class="keyword">const</span> cardinality_i=eval.template get_storage_dim&lt;3&gt;(in2());</div><div class="line">                uint_t <span class="keyword">const</span> cardinality_j=eval.template get_storage_dim&lt;4&gt;(in2());</div><div class="line">                uint_t <span class="keyword">const</span> faces_=eval.template get_storage_dim&lt;5&gt;(in2());</div><div class="line"></div><div class="line">                <span class="comment">//for all dofs in a boundary face</span></div><div class="line">                <span class="keywordflow">for</span>(short_t I=0; I&lt;cardinality_i; I++)</div><div class="line">                    <span class="keywordflow">for</span>(short_t J=0; J&lt;cardinality_j; J++)</div><div class="line">                        <span class="keywordflow">for</span>(short_t K=0; K&lt;faces_; K++)</div><div class="line">                        {</div><div class="line">                            eval(out(row+I)) += eval(in2(row+I, col+J, face+K)*in1(row+J));</div><div class="line">                        }</div><div class="line">            }</div><div class="line">        };</div><div class="line">        <span class="comment">// [matvec_bd]</span></div><div class="line"></div><div class="line">    } <span class="comment">//namespace functors</span></div><div class="line">} <span class="comment">//namespace gdl</span></div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Apr 5 2017 09:06:12 for Galerkin4GT by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.12 </li>
  </ul>
</div>
</body>
</html>
