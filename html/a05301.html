<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Galerkin4GT: Galerking Discretization (continuous)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Galerkin4GT
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">Contributive effort to implement proof-of-concept Galerkin methods on new HPC architectures</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a05301.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Galerking Discretization (continuous) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This and the following examples shows how GridTools implements two different flavours of the Galerkin Finite Elements discretization, using tensor product brick elements. We will assume that GridTools is a black-box, and we will only describe the use of the exposed API, without digging into the multi-platform implementations, optimizations, and software architecture.</p>
<p>The goal of these examples is to show as a proof of concept the possibility of using a Third Party Library (TPL), in this case the Intrepid packege in Trilinos, with the numerical tools and basic definitions already in place, in order to build a custom finite elements assembly of a differential operator using gridtools, thus taking advantage of all the advanced multi-platform optimizations of the library.</p>
<p>The Intrepid TPL provides the definition of several basis functions, quadrature rules, elemantal operations (e.g. scalar/vector products, curl, gradient, divergence, ...).</p>
<h1><a class="anchor" id="sec_fe_pb_description"></a>
Problem Description</h1>
<p>Let us describe quickly and pragmatically the problem that we want to solve. We aim at solving integrals of the following type, which come from the variational formulation of a partial differential equation:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int_{\Omega}{\phi(\mathbf x)\psi(\mathbf x)}d\Omega \]" src="form_6.png"/>
</p>
<p>where <img class="formulaInl" alt="$\psi$" src="form_7.png"/> and <img class="formulaInl" alt="$\phi$" src="form_8.png"/> are known functions on the domain <img class="formulaInl" alt="$\Omega$" src="form_9.png"/>. In the classical Galerkin methods the domain is split into mesh "elements", and the integral above is computed elementwise, as sum of all the contributions </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sum_e\int_{\Omega_e}{\phi(\mathbf x)\psi(\mathbf x)}d\Omega \]" src="form_10.png"/>
</p>
<p>The next step of the discretization is the finite elements map to the reference element (an hypercube with coordinates <img class="formulaInl" alt="$\{(\pm1,0,0...), (0,\pm1,0,...), (0,0,\pm1,...) ...\}$" src="form_11.png"/>): to solve the integral we build a map </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ x:\mathbb R^n \rightarrow \mathbb R^n \]" src="form_12.png"/>
</p>
<p> such that </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \hat\Omega_e\mapsto\Omega_e, \]" src="form_13.png"/>
</p>
<p> and use this map to perform a change of varialbe in the integral.</p>
<p>The integral above after the change of coordinates becomes</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \int_{\hat\Omega_e}{\phi(\hat{\mathbf x})\psi(\hat{\mathbf x})J(\hat{\mathbf x})}d\hat\Omega \]" src="form_14.png"/>
</p>
<p>where </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[J=\frac{\partial x}{\partial\hat x}\]" src="form_15.png"/>
</p>
<p> is the jacobian of the transformation (a constant in the case in which <img class="formulaInl" alt="$x$" src="form_16.png"/> is an affine map).</p>
<p>One main difference between the usual finite-difference stencil-like computations is that we do not iterate over points in the global domain: now we want to iterate over elements. To this end we generalize the GridTools concept of iteration point to an element by extending the storage dimensionality: if for the finite difference case we had a 3D storage and we were iterating on i, j, and k, now each (i,j,k) point identifies an element, and the points inside the element will be accessed using 4 indices (i,j,k,dof) for the point (dof) whithin element (i,j,k).</p>
<p>We have, as input, the grid (i.e. the location of the dicretization points in the actual domain), the evaluation of the basis functions computed in the quadrature points in the reference element, and the evaluation of the geometric map in the same quadrature points. The integration can be carried out in the following steps (stages)</p><ul>
<li>compute the jacobian in the quadrature points</li>
<li>compute the value of the integral locally to each element</li>
<li>assembly the contribution of the different elements (i.e. sum up the contributions in the nodes which are overlapping between several elements)</li>
</ul>
<p>Notice that the last point is not necessary if the discrete finite elements space is discontinuous between the elements, it would be replaced by a flux computation and exchange.</p>
<p>In the simplistic case of 4 linear quadrilateral continuous elements, as shown in the picture below, we have to merge the 4 quadrilaterals into the one on the right: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \fbox{ \begin{tikzpicture}[shorten &gt;=1pt,auto,node distance=1.5cm, thick,main node/.style={circle,fill=blue!40,draw,font=\sffamily\small\bfseries}, thick,main node2/.style={circle,fill=green!40,draw,font=\sffamily\small\bfseries}, thick,main node3/.style={circle,fill=cyan!40,draw,font=\sffamily\small\bfseries}, thick,other node/.style={circle,fill=yellow!40,draw,font=\sffamily\small\bfseries}, thick,white node/.style={circle,draw,font=\sffamily\small\bfseries} ] \node[main node] (21) {$e_1$}; \node[main node] (22) [left of=21] {$e_1$}; \node[main node] (23) [below of=22] {$e_1$}; \node[main node] (24) [right of=23] {$e_1$}; \node[main node2] (2) [right of=21] {$e_2$}; \node[main node2] (1) [right of=2] {$e_2$}; \node[main node2] (3) [below of=2] {$e_2$}; \node[main node2] (4) [right of=3] {$e_2$}; \node[other node] (5) [below of=4] {$e_4$}; \node[other node] (6) [left of=5] {$e_4$}; \node[other node] (7) [below of=6] {$e_4$}; \node[other node] (8) [right of=7] {$e_4$}; \node[main node3] (31) [left of=6] {$e_3$}; \node[main node3] (32) [left of=31] {$e_3$}; \node[main node3] (33) [below of=32] {$e_3$}; \node[main node3] (34) [right of=33] {$e_3$}; \node[main node3] (9) [below right of=4] {$e_{13}$}; \node[other node] (10) [right of=9] {$e_{1234}$}; \node[main node] (11) [below right of=1] {$e_{1}$}; \node[white node] (12) [below right of=5] {$e_{3}$}; \node[main node2] (13) [right of=11] {$e_{12}$}; \node[white node] (14) [right of=12] {$e_{34}$}; \node[white node] (15) [right of=14] {$e_{4}$}; \node[white node] (16) [right of=10] {$e_{24}$}; \node[white node] (17) [right of=13] {$e_2$}; \path[every node/.style={font=\sffamily\small}] (1) edge node [left] {} (4) (2) edge node [right] {} (1) (3) edge node [right] {} (2) (4) edge node [left] {} (3) (5) edge node [left] {} (8) (6) edge node [right] {} (5) (7) edge node [right] {} (6) (8) edge node [left] {} (7) (22) edge node {} (21) (22) edge node {} (23) (23) edge node {} (24) (24) edge node {} (21) (32) edge node {} (31) (32) edge node {} (33) (33) edge node {} (34) (34) edge node {} (31) (17) edge node {} (13) (16) edge node {} (10) (17) edge node {} (16) (16) edge node {} (15); \path[every node/.style={font=\sffamily\small}] (11) edge node {} (9) (12) edge node {} (9) (10) edge node {} (13) (10) edge node {} (14) (9) edge node {} (10) (11) edge node {} (13) (12) edge node {} (14) (14) edge node {} (15) ; \end{tikzpicture} }\]" src="form_17.png"/>
</p>
<p> where the pedix index represents the elements which contributed to the value on the node.</p>
<p>The operation performed is a gather of k values, where k is the number of elements sharing the same point, as shown schematically in the next picture </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \fbox{ \newcommand\crule[3][black]{\textcolor{#1}{\rule{#2}{#3}}} \begin{tikzpicture}[shorten &gt;=1pt,auto,node distance=1.5cm, thick,main node/.style={font=\sffamily\small\bfseries} ] \node[main node] (1) {\crule[black]{10pt}{10pt}\crule[red]{10pt}{10pt}\crule[black]{10pt}{10pt}\crule[green]{10pt}{10pt}}; \node[main node] (9) [left of=1] {$[e_1,e_1,e_1,e_1]\;\;$}; \node[main node] (2) [right of=1] {\crule{10pt}{10pt}}; \node[main node] (13) [right of=2] {$[e_1+e_2+e_3+e_4]$}; \node[main node] (3) [below of=1]{\crule[black]{10pt}{10pt}\crule[red]{10pt}{10pt}\crule[black]{10pt}{10pt}\crule[green]{10pt}{10pt}}; \node[main node] (10) [left of=3] {$[e_2,e_2,e_2,e_2]\;\;$}; \node[main node] (4) [right of=3] {\crule{10pt}{10pt}}; \node[main node] (5) [below of=3]{\crule[black]{10pt}{10pt}\crule[red]{10pt}{10pt}\crule[black]{10pt}{10pt}\crule[green]{10pt}{10pt}}; \node[main node] (11) [left of=5] {$[e_3,e_3,e_3,e_3]\;\;$}; \node[main node] (6) [right of=5] {\crule{10pt}{10pt}}; \node[main node] (7) [below of=5]{\crule[black]{10pt}{10pt}\crule[red]{10pt}{10pt}\crule[black]{10pt}{10pt}\crule[green]{10pt}{10pt}}; \node[main node] (12) [left of=7] {$[e_4,e_4,e_4,e_4]\;\;$}; \node[main node] (8) [right of=7] {\crule{10pt}{10pt}}; \draw[in=90, out=90] ([xshift=-15pt]1.north) to node [below] {} (2) ; \draw[in=-90, out=90] ([xshift=-5pt]3.north) to node [below] {} (2) ; \draw[in=-90, out=90] ([xshift=5pt]5.north) to node [below] {} (2) ; \draw[in=-90, out=90] ([xshift=15pt]7.north) to node [below] {} (2) ; \end{tikzpicture} } \]" src="form_18.png"/>
</p>
<h1><a class="anchor" id="sec_structure"></a>
Structure of the code</h1>
<p>The Galerkin discretization infrastructure is implemented in several files:</p><ul>
<li><a class="el" href="a03086.html">element_traits.hpp</a> defines the link between the GridTools and Intrepid interfaces. The basis funcitons currently included are listed in the included headers <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Intrepid_Basis.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;Intrepid_Types.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;Intrepid_FieldContainer.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;Intrepid_HGRAD_TET_COMP12_FEM.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;Intrepid_HGRAD_TET_Cn_FEM_ORTH.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;Intrepid_HGRAD_TET_Cn_FEM.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;Intrepid_HGRAD_TRI_Cn_FEM.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;Intrepid_HGRAD_LINE_Cn_FEM.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;Intrepid_HGRAD_TET_C1_FEM.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;Intrepid_HGRAD_TRI_C1_FEM.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;Intrepid_HGRAD_LINE_C1_FEM.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;Intrepid_HGRAD_TET_C2_FEM.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;Intrepid_HGRAD_TRI_C2_FEM.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;Intrepid_HGRAD_HEX_C2_FEM.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;Intrepid_HGRAD_HEX_C1_FEM.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;Intrepid_HGRAD_HEX_Cn_FEM.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;Intrepid_HGRAD_QUAD_C2_FEM.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;Intrepid_HGRAD_HEX_Cn_FEM.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;Intrepid_HGRAD_QUAD_Cn_FEM.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;Intrepid_HDIV_HEX_In_FEM.hpp&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;legendre.hpp&quot;</span></div><div class="line"><span class="preprocessor">#ifndef __CUDACC__ //not yet</span></div><div class="line"><span class="preprocessor">#include &quot;../playground/numerics/b_splines.hpp&quot;</span></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --></li>
<li><p class="startli"><a class="el" href="a03074.html">basis_functions.hpp</a> contains the definition of a reference element, which is univocally determined by three template arguments:</p><ul>
<li>the order of the basis defined on this element</li>
<li>the type of the basis (e.g. Lagrange, Raviart-Thomas, Nedelec, BDM, Legendre, ...)</li>
<li>the shape of the element (e.g. Hexahedron, Quadrilateral, Line, ...)</li>
</ul>
<p class="startli">This structure is used to define the discretization of both the geometric map (reference to current configuration) and of the solution. So we can in principle use arbitrary elements types with arbitrary geometric maps, as long as the element shape is the same. The <a class="el" href="a03195.html#a8ec35b22619016b3d41f56fbf009c166">basis</a> and the <a class="el" href="a03195.html#a32a20768f109bc5ca57091ba8a99df31">shape</a> are chosen by the user by passing specific tags as template argument, which are defined in <a class="el" href="a03050.html">galerkin_defs.hpp</a>. An example can be found in <a class="el" href="a02960.html">mass.cpp</a></p>
</li>
<li><a class="el" href="a03083.html">cubature.hpp</a> contains the definition of the cubature rule, i.e. the points and weights which are used for the numerical computation on an integral on the reference element. The cubature rule is univocally defined by specifying its order and <a class="el" href="a03195.html#a32a20768f109bc5ca57091ba8a99df31">shape</a> as template arguments.</li>
<li><a class="el" href="a03089.html">intrepid.hpp</a> is responsible for computing the elemental quantities used in the assembly. It defines two main structures:<ul>
<li>the <a class="el" href="a04394.html">discretization</a>, which contains the basis functions and local information concerning the finite elements discretization of the solution</li>
<li>the <a class="el" href="a04402.html">geometry</a>, which derives from the discretization, contains basis functions and local information used for the interpolation of the grid points in the current configuration, and additionally it contains the coordinates of the element points in the reference domain (the "local grid").</li>
</ul>
</li>
<li><a class="el" href="a03062.html">assembly.hpp</a> contains the part of the assembly which is common to most of the Galerkin discretizations, and thus hidden from the user code. This part is responsible for computing all the quanties needed for performing an integral on the current domain configuration, namely the jacobian of the geometric map (i.e. the map of an element from the reference configuration to the current one), its determinant, and its inverse. This structure thus depends exclusively on the geometric map, and not on the finite elements used for the discretization of the fields. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Mar 29 2017 16:45:59 for Galerkin4GT by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.12 </li>
  </ul>
</div>
</body>
</html>
