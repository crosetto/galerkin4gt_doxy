<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Galerkin4GT: I/O Example (cubed sphere grid)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Galerkin4GT
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">Contributive effort to implement proof-of-concept Galerkin methods on new HPC architectures</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a05318.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">I/O Example (cubed sphere grid) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section note"><dt>Note</dt><dd>This examples requires the library to be configured with Xdmf and HDF5 support. follow the instructions in <a class="el" href="a05325.html">Installation instructions</a> in order to properly configure the library.</dd></dl>
<h2>How to export the solution </h2>
<p>This example shows how to export the solution and the grid to a file. The output file is written in binary format using the Xdmf library (which supports HDF5). The solution can be visualized and post-processed using e.g. Paraview.</p>
<p>As in the other examples we start instantiating a storage for the grid </p><div class="fragment"><div class="line">    meta_t info( d1, d2, d3 , d4, 3 );</div><div class="line"></div><div class="line">    storage_type storage_(info, 0.);</div></div><!-- fragment --><p>with d1xd2xd3 elements for a 3D mesh, while d4 is the number of local degrees of freedom (i.e. 2x2x2=8 for a first order hexahedral mesh), while the last dimension (3) represents the space dimensionality of the filed in which the mesh is embedded (i.e. the number of coodrinates each mesh point has).</p>
<p>The domain we discretize is the cube (-0.5x0.5, -0.5x0.5, 1x2) </p><div class="fragment"><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d1; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;d2; ++j)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;d3; ++k)</div><div class="line">            {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l=0; l&lt;ld1; ++l)</div><div class="line">                {</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;ld2; ++m)</div><div class="line">                    {</div><div class="line">                        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n=0; n&lt;ld3; ++n)</div><div class="line">                        {   <span class="comment">//grid coordinates, low left corner in (-.5,-.5,1.)</span></div><div class="line">                            <span class="keywordtype">double</span> x=(i*ld1+l)/((<span class="keywordtype">double</span>)(d1-1)*ld1+(ld1-1))-.5;</div><div class="line">                            <span class="keywordtype">double</span> y=(j*ld2+m)/((<span class="keywordtype">double</span>)(d2-1)*ld2+(ld2-1))-.5;</div><div class="line">                            <span class="keywordtype">double</span> z=(k*ld3+n)/((<span class="keywordtype">double</span>)(d3-1)*ld3+(ld3-1))+1.;</div><div class="line">                            storage_(i,j,k,n*ld1*ld2+m*ld1+l, 0)= (<a class="code" href="a04769.html">double</a>) (x);</div><div class="line">                            storage_(i,j,k,n*ld1*ld2+m*ld1+l, 1)= (<a class="code" href="a04769.html">double</a>) (y);</div><div class="line">                            storage_(i,j,k,n*ld1*ld2+m*ld1+l, 2)= (<a class="code" href="a04769.html">double</a>) (z);</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div></div><!-- fragment --><p> We define then a scalar field, which is the displacement <img class="formulaInl" alt="$\mathbf d$" src="form_0.png"/> applied to the grid points in order to obtain a face of the cubed sphere The displacement is computed with the following formula </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left( \begin{array}{c} d_1\\d_2\\d_3 \end{array} \right) = \left( \begin{array}{c} x\cdot \sqrt{1-(\frac{y^2}2)-(\frac12)+(\frac{y^2}3)}\cdot(1+z/10)-x\\ y\cdot \sqrt{1-(\frac{x^2}2)-(\frac12)+(\frac{x^2}3)}\cdot(1+z/10)-y\\ \sqrt{1-(\frac{y^2}2)-(\frac(x^2)2)+(\frac{x\cdot y}3)}\cdot(1+z/10)-z \end{array} \right) \]" src="form_1.png"/>
</p>
 <div class="fragment"><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d1; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;d2; ++j)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;d3; ++k)</div><div class="line">            {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> l=0; l&lt;ld1; ++l)</div><div class="line">                {</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> m=0; m&lt;ld2; ++m)</div><div class="line">                    {</div><div class="line">                        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n=0; n&lt;ld3; ++n)</div><div class="line">                        {   <span class="comment">// field constant on the elements</span></div><div class="line">                            <span class="comment">// field_(i,j,k,n*ld1*ld2+m*ld1+l)= (double) i+j+k;</span></div><div class="line">                            <span class="keywordtype">double</span> x=(i*ld1+l)/((<span class="keywordtype">double</span>)(d1-1)*ld1+(ld1-1))-.5;</div><div class="line">                            <span class="keywordtype">double</span> y=(j*ld2+m)/((<span class="keywordtype">double</span>)(d2-1)*ld2+(ld2-1))-.5;</div><div class="line">                            <span class="keywordtype">double</span> z=(k*ld3+n)/((<span class="keywordtype">double</span>)(d3-1)*ld3+(ld3-1))+1.;</div><div class="line">                            <span class="comment">//std::cout&lt;&lt;&quot; x: &quot;&lt;&lt;x&lt;&lt;&quot; y: &quot;&lt;&lt;y&lt;&lt;&quot; z: &quot;&lt;&lt;z&lt;&lt;std::endl;</span></div><div class="line">                            <span class="keywordtype">double</span> sph1= x*std::sqrt(1-(std::pow(y,2)/2.)-(std::pow(1., 2)/2.)+(std::pow(y*1., 2)/3.)) ;</div><div class="line">                            <span class="keywordtype">double</span> sph2= y*std::sqrt(1-(std::pow(x,2)/2.)-(std::pow(1., 2)/2.)+(std::pow(x*1., 2)/3.)) ;</div><div class="line">                            <span class="keywordtype">double</span> sph3= 1.*std::sqrt(1-(std::pow(y,2)/2.)-(std::pow(x, 2)/2.)+(std::pow(y*x, 2)/3.)) ;</div><div class="line">                            field_(i,j,k,n*ld1*ld2+m*ld1+l,0)= sph1+sph1*z*0.1-x ;</div><div class="line">                            field_(i,j,k,n*ld1*ld2+m*ld1+l,1)= sph2+sph2*z*0.1-y ;</div><div class="line">                            field_(i,j,k,n*ld1*ld2+m*ld1+l,2)= sph3+sph3*z*0.1-z ;</div><div class="line"></div><div class="line">                            scalar_field_(i,j,k,n*ld1*ld2+m*ld1+l)= z;</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div></div><!-- fragment --><p> The current Xdmf exporter works for structured grids. In order to use it one has to create a storage_info for the local elements, and instantiate an object of type <code>io_rectilinear</code>. Once constucted we can add scalar or vector data to be exported by calling its <code>set_attribute_scalar</code> and <code>set_attribute_vecgtor</code> member functions. Eventually we call <code>write</code> specifying a filename to write out everything.</p>
<div class="fragment"><div class="line">    <span class="keyword">typedef</span> backend_t::storage_info&lt;0, gridtools::layout_map&lt;0,1,2&gt; &gt; meta_local_t;</div><div class="line">    meta_local_t meta_local_(ld1, ld2, ld3);</div><div class="line">    <a class="code" href="a04622.html">gdl::io_rectilinear&lt;storage_type, meta_local_t&gt;</a> io_(storage_, meta_local_);</div><div class="line">    io_.set_information(<span class="stringliteral">&quot;Time&quot;</span>);</div><div class="line">    io_.template set_attribute_vector&lt;0&gt;(field_, <span class="stringliteral">&quot;test value&quot;</span>);</div><div class="line">    io_.template set_attribute_scalar&lt;0&gt;(scalar_field_, <span class="stringliteral">&quot;z&quot;</span>);</div><div class="line">    io_.write(<span class="stringliteral">&quot;fuck&quot;</span>);</div></div><!-- fragment --><p> Executing this will generate two files: an XML file with extension ".xmf", and a binary file with extension ".h5". The lattter contains the output in HDF5 format, while the former is a description used by the visualization software (e.g. ParaView) in order to properly access the HDF5 file. These two files must be in the same folder in order for the visualization to work properly. Starting Paraview in order to visualize the solution one has to first load the ".xmf" file, choosing the Xdmf3 reader. Then press "apply", and a cube should appear on the display. Pressing the "warp" button, and again "apply" this cube is mapped to a cubed sphere. In order to better visualize the domain one can select from the top bar, instead of "Outline", "Surface With Edges", and an image like the following one should appear in the rendering view. Note that the mesh points are duplicated at each elements, which allows to correctly represent jumps in case of discontinuities across the element boundaries.</p>
<div class="image">
<img src="cubed_sphere.png" alt="cubed_sphere.png"/>
</div>
 </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Apr 5 2017 09:06:11 for Galerkin4GT by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.12 </li>
  </ul>
</div>
</body>
</html>
