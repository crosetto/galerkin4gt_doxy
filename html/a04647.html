<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Galerkin4GT: poisson.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Galerkin4GT
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">Contributive effort to implement proof-of-concept Galerkin methods on new HPC architectures</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a04647.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">poisson.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">  GridTools Libraries</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  Copyright (c) 2016, GridTools Consortium</span></div><div class="line"><span class="comment">  All rights reserved.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  Redistribution and use in source and binary forms, with or without</span></div><div class="line"><span class="comment">  modification, are permitted provided that the following conditions are</span></div><div class="line"><span class="comment">  met:</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  1. Redistributions of source code must retain the above copyright</span></div><div class="line"><span class="comment">  notice, this list of conditions and the following disclaimer.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  2. Redistributions in binary form must reproduce the above copyright</span></div><div class="line"><span class="comment">  notice, this list of conditions and the following disclaimer in the</span></div><div class="line"><span class="comment">  documentation and/or other materials provided with the distribution.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  3. Neither the name of the copyright holder nor the names of its</span></div><div class="line"><span class="comment">  contributors may be used to endorse or promote products derived from</span></div><div class="line"><span class="comment">  this software without specific prior written permission.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span></div><div class="line"><span class="comment">  &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span></div><div class="line"><span class="comment">  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span></div><div class="line"><span class="comment">  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span></div><div class="line"><span class="comment">  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span></div><div class="line"><span class="comment">  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span></div><div class="line"><span class="comment">  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span></div><div class="line"><span class="comment">  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span></div><div class="line"><span class="comment">  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span></div><div class="line"><span class="comment">  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span></div><div class="line"><span class="comment">  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  For information: http://eth-cscs.github.io/gridtools/</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define REORDER</span></div><div class="line"><span class="preprocessor">#define DEAL_II_ORDERING</span></div><div class="line"></div><div class="line"><span class="comment">// TODO: clean include list, assembly.hpp should not be here</span></div><div class="line"><span class="comment">// TODO: remove this pedantic</span></div><div class="line"><span class="preprocessor">#define PEDANTIC_DISABLED</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iomanip&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;../numerics/assembly.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../numerics/assemble_storage.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../numerics/linear_solver.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../functors/stiffness.hpp&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="a03201.html">gdl</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="a03207.html">gdl::enumtype</a>;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="a03201.html">gdl</a> {</div><div class="line"></div><div class="line">    <span class="keyword">namespace </span><a class="code" href="a03209.html">functors</a> {</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Geometry, enumtype::Shape S=Geometry::parent_shape &gt;</div><div class="line">        <span class="keyword">struct </span>cubature_point_grid_generation {</div><div class="line"></div><div class="line">            <span class="keyword">using</span> cub=<span class="keyword">typename</span> Geometry::cub;</div><div class="line">            <span class="keyword">typedef</span> gt::accessor&lt;0, enumtype::in, gt::extent&lt;0,0,0,0&gt; , 5&gt; <span class="keyword">const</span> grid_points;</div><div class="line">            <span class="keyword">typedef</span> gt::accessor&lt;1, enumtype::in, gt::extent&lt;0,0,0,0&gt; , 3&gt; <span class="keyword">const</span> phi;</div><div class="line">            <span class="keyword">typedef</span> gt::accessor&lt;2, enumtype::inout, gt::extent&lt;0,0,0,0&gt; , 5&gt; transf_grid_points;</div><div class="line">            <span class="keyword">typedef</span> boost::mpl::vector&lt; grid_points, phi, transf_grid_points&gt; arg_list;</div><div class="line"></div><div class="line">            <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Evaluation&gt;</div><div class="line">            GT_FUNCTION</div><div class="line">            <span class="keyword">static</span> <span class="keywordtype">void</span> Do(Evaluation <span class="keyword">const</span> &amp; eval, x_interval) {</div><div class="line">                gt::dimension&lt;1&gt; dof_coord_phi;</div><div class="line">                gt::dimension&lt;2&gt; cub_dim_phi;</div><div class="line">                gt::dimension&lt;4&gt; point_dim;</div><div class="line">                gt::dimension&lt;5&gt; coord_dim;</div><div class="line"></div><div class="line">                uint_t <span class="keyword">const</span> num_cub_points=eval.template get_storage_dim&lt;1&gt;(phi());</div><div class="line">                uint_t <span class="keyword">const</span> basis_cardinality=eval.template get_storage_dim&lt;0&gt;(phi());</div><div class="line"></div><div class="line"><span class="preprocessor">#ifndef __CUDACC__</span></div><div class="line">                assert(num_cub_points==cub::numCubPoints());</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">                <span class="comment">//TODO dimensions should be generic</span></div><div class="line">                <span class="keywordflow">for</span>(short_t coord=0; coord&lt; shape_property&lt;Geometry::parent_shape&gt;::dimension; ++coord)</div><div class="line">                {</div><div class="line">                    <span class="keywordflow">for</span>(short_t cub_point=0; cub_point&lt; num_cub_points; ++cub_point)</div><div class="line">                    {</div><div class="line">                        eval( transf_grid_points(point_dim + cub_point, coord_dim + coord) ) = 0.;</div><div class="line">                        <span class="keywordflow">for</span> (int_t dof=0; dof &lt; basis_cardinality ; ++dof)</div><div class="line">                        {</div><div class="line">                          eval( transf_grid_points(point_dim + cub_point, coord_dim + coord) ) +=</div><div class="line">                            eval(grid_points(point_dim+dof,coord_dim+coord)*!phi(dof,cub_point,0));</div><div class="line">                        }</div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        };</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> FunctionDefinition&gt;</div><div class="line">        <span class="keyword">struct </span>function_evaluation {</div><div class="line"></div><div class="line">            <span class="keyword">typedef</span> gt::accessor&lt;0, enumtype::in, gt::extent&lt;0,0,0,0&gt; , 5&gt; <span class="keyword">const</span> grid_points;</div><div class="line">            <span class="keyword">typedef</span> gt::accessor&lt;1, enumtype::inout, gt::extent&lt;0,0,0,0&gt; , 4&gt; function_values;</div><div class="line">            <span class="keyword">typedef</span> boost::mpl::vector&lt; grid_points, function_values&gt; arg_list;</div><div class="line"></div><div class="line">            <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Evaluation&gt;</div><div class="line">            GT_FUNCTION</div><div class="line">            <span class="keyword">static</span> <span class="keywordtype">void</span> Do(Evaluation <span class="keyword">const</span> &amp; eval, x_interval) {</div><div class="line">                gt::dimension&lt;4&gt; point_dim;</div><div class="line">                gt::dimension&lt;5&gt; coord_dim;</div><div class="line"></div><div class="line">                uint_t <span class="keyword">const</span> num_cub_points=eval.template get_storage_dim&lt;3&gt;(grid_points());</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span>(short_t cub_point=0; cub_point&lt; num_cub_points; ++cub_point)</div><div class="line">                {</div><div class="line"></div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> x = eval(grid_points(point_dim+cub_point,coord_dim+0));</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> y = eval(grid_points(point_dim+cub_point,coord_dim+1));</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> z = eval(grid_points(point_dim+cub_point,coord_dim+2));</div><div class="line"></div><div class="line">                  eval(function_values(point_dim+cub_point)) = FunctionDefinition::compute(x,y,z);</div><div class="line">                }</div><div class="line">            }</div><div class="line">        };</div><div class="line"></div><div class="line">        <span class="keyword">struct </span>quartic_source {</div><div class="line">            <span class="comment">// TODO: GT_FUNCTION needed here?</span></div><div class="line">          <span class="keyword">static</span> float_t compute(float_t i_x, float_t i_y, float_t i_z) {</div><div class="line">                <span class="keywordflow">return</span> 4.*(i_x*i_x*i_x*i_x + i_y*i_y*i_y*i_y + i_z*i_z*i_z*i_z);</div><div class="line">            }</div><div class="line">        };</div><div class="line"></div><div class="line">        <span class="keyword">struct </span>quadratic_boundary_value {</div><div class="line">            <span class="comment">// TODO: GT_FUNCTION needed here?</span></div><div class="line">          <span class="keyword">static</span> float_t compute(float_t i_x, float_t i_y, float_t i_z) {</div><div class="line">                <span class="keywordflow">return</span> i_x*i_x + i_y*i_y + i_z*i_z;</div><div class="line">            }</div><div class="line">        };</div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">// TODO: move this functor to interpolate.hpp</span></div><div class="line">        <span class="comment">// [not_normalized_transform]</span></div><div class="line">        <span class="keyword">struct </span>not_normalized_transform {</div><div class="line"></div><div class="line">            <span class="keyword">using</span> jac_det=gt::accessor&lt;0, enumtype::in   , gt::extent&lt;&gt; , 4&gt; <span class="keyword">const</span>;</div><div class="line">            <span class="keyword">using</span> weights   =gt::accessor&lt;1, enumtype::inout, gt::extent&lt;&gt; , 3&gt; ;</div><div class="line">            <span class="keyword">using</span> phi   =gt::accessor&lt;2, enumtype::in   , gt::extent&lt;&gt; , 3&gt; <span class="keyword">const</span>;</div><div class="line">            <span class="keyword">using</span> in   =gt::accessor&lt;3, enumtype::in   , gt::extent&lt;&gt; , 4&gt; <span class="keyword">const</span>;</div><div class="line">            <span class="keyword">using</span> out   =gt::accessor&lt;4, enumtype::inout, gt::extent&lt;&gt; , 4&gt; ;</div><div class="line">            <span class="keyword">using</span> arg_list=boost::mpl::vector&lt; jac_det, weights, phi, in, out &gt; ;</div><div class="line"></div><div class="line">            <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Evaluation&gt;</div><div class="line">            GT_FUNCTION</div><div class="line">            <span class="keyword">static</span> <span class="keywordtype">void</span> Do(Evaluation <span class="keyword">const</span> &amp; eval, x_interval) {</div><div class="line">                gt::dimension&lt;4&gt; qp;</div><div class="line">                gt::dimension&lt;5&gt; dimx;</div><div class="line"></div><div class="line">                uint_t <span class="keyword">const</span> num_cub_points=eval.template get_storage_dim&lt;1&gt;(phi());</div><div class="line">                uint_t <span class="keyword">const</span> basis_cardinality=eval.template get_storage_dim&lt;0&gt;(phi());</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span>(short_t P_i=0; P_i&lt;basis_cardinality; ++P_i) <span class="comment">// current dof</span></div><div class="line">                {</div><div class="line">                    eval(out((uint_t)0,(uint_t)0,(uint_t)0,(uint_t)P_i))=0.;</div><div class="line">                    <span class="keywordflow">for</span>(short_t q=0; q&lt;num_cub_points; ++q){</div><div class="line">                      assert(eval(jac_det(qp+q)));</div><div class="line">                      eval(out((uint_t)0,(uint_t)0,(uint_t)0,(uint_t)P_i))  +=</div><div class="line">                        eval(!phi(P_i,q,0)*in(qp+q)*!weights(q,0,0)*jac_det(qp+q));</div><div class="line"></div><div class="line">                    }</div><div class="line">                }</div><div class="line">            }</div><div class="line">        };</div><div class="line"></div><div class="line">        <span class="comment">// TODO: refactoring of bc application functors required</span></div><div class="line">        <span class="comment">// TODO: avoid overlap in assignement/computation</span></div><div class="line">        <span class="keyword">template</span> &lt;u<span class="keywordtype">short</span>_t N_DOF0, u<span class="keywordtype">short</span>_t N_DOF1, u<span class="keywordtype">short</span>_t N_DOF2, <span class="keyword">typename</span> BoundaryFunctionDefinition&gt;</div><div class="line">        <span class="keyword">struct </span>apply_dirichlet_boundary_conditions_top {</div><div class="line"></div><div class="line">            <span class="keyword">using</span> grid_points=gt::accessor&lt;0, enumtype::in, gt::extent&lt;0,0,0,0&gt; , 5&gt; <span class="keyword">const</span>;</div><div class="line">            <span class="keyword">using</span> stiff=gt::accessor&lt;1, enumtype::inout, gt::extent&lt;0,0,0,0&gt; , 5&gt; ;</div><div class="line">            <span class="keyword">using</span> source=gt::accessor&lt;2, enumtype::inout, gt::extent&lt;0,0,0,0&gt; , 4&gt; ;</div><div class="line">            <span class="keyword">using</span> arg_list= boost::mpl::vector&lt;grid_points, stiff, source&gt;;</div><div class="line"></div><div class="line">            <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Evaluation&gt;</div><div class="line">            GT_FUNCTION</div><div class="line">            <span class="keyword">static</span> <span class="keywordtype">void</span> Do(Evaluation <span class="keyword">const</span> &amp; eval, x_interval) {</div><div class="line"></div><div class="line">                gt::dimension&lt;4&gt; point_dim;</div><div class="line">                gt::dimension&lt;5&gt; coord_dim;</div><div class="line">                gt::dimension&lt;4&gt; dof1;</div><div class="line">                gt::dimension&lt;5&gt; dof2;</div><div class="line"></div><div class="line">                constexpr gt::meta_storage_base&lt;static_int&lt;__COUNTER__&gt;,gt::layout_map&lt;2,1,0&gt;,<span class="keyword">false</span>&gt; indexing{N_DOF0,N_DOF1,N_DOF2};</div><div class="line">                uint_t <span class="keyword">const</span> num_dof=eval.template get_storage_dim&lt;4&gt;(stiff());</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span>(short_t I1=0; I1&lt;indexing.template dim&lt;0&gt;(); I1++)</div><div class="line">                    <span class="keywordflow">for</span>(short_t J1=0; J1&lt;indexing.template dim&lt;1&gt;(); J1++)</div><div class="line">                        <span class="keywordflow">for</span>(short_t i=0; i&lt;num_dof; i++) {</div><div class="line">                            eval(stiff(dof1+indexing.index(J1,0,I1),dof2+i)) = 0.;</div><div class="line">                            eval(stiff(dof2+indexing.index(J1,0,I1),dof1+i)) = 0.;</div><div class="line">                        }</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span>(short_t I1=0; I1&lt;indexing.template dim&lt;0&gt;(); I1++)</div><div class="line">                    <span class="keywordflow">for</span>(short_t J1=0; J1&lt;indexing.template dim&lt;1&gt;(); J1++)</div><div class="line">                    {</div><div class="line">                        eval(stiff(dof1+indexing.index(J1,0,I1),dof2+indexing.index(J1,0,I1))) = 1.;</div><div class="line"></div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> x = eval(grid_points(point_dim+indexing.index(J1,0,I1),coord_dim+0));</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> y = eval(grid_points(point_dim+indexing.index(J1,0,I1),coord_dim+1));</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> z = eval(grid_points(point_dim+indexing.index(J1,0,I1),coord_dim+2));</div><div class="line"></div><div class="line">                        eval(source(dof1+indexing.index(J1,0,I1))) = BoundaryFunctionDefinition::compute(x,y,z);</div><div class="line">                    }</div><div class="line">            }</div><div class="line">        };</div><div class="line"></div><div class="line">        <span class="keyword">template</span> &lt;u<span class="keywordtype">short</span>_t N_DOF0, u<span class="keywordtype">short</span>_t N_DOF1, u<span class="keywordtype">short</span>_t N_DOF2, <span class="keyword">typename</span> BoundaryFunctionDefinition&gt;</div><div class="line">        <span class="keyword">struct </span>apply_dirichlet_boundary_conditions_bottom {</div><div class="line"></div><div class="line">            <span class="keyword">using</span> grid_points=gt::accessor&lt;0, enumtype::in, gt::extent&lt;0,0,0,0&gt; , 5&gt; <span class="keyword">const</span>;</div><div class="line">            <span class="keyword">using</span> stiff=gt::accessor&lt;1, enumtype::inout, gt::extent&lt;0,0,0,0&gt; , 5&gt; ;</div><div class="line">            <span class="keyword">using</span> source=gt::accessor&lt;2, enumtype::inout, gt::extent&lt;0,0,0,0&gt; , 4&gt; ;</div><div class="line">            <span class="keyword">using</span> arg_list= boost::mpl::vector&lt;grid_points, stiff, source&gt;;</div><div class="line"></div><div class="line">            <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Evaluation&gt;</div><div class="line">            GT_FUNCTION</div><div class="line">            <span class="keyword">static</span> <span class="keywordtype">void</span> Do(Evaluation <span class="keyword">const</span> &amp; eval, x_interval) {</div><div class="line"></div><div class="line">                gt::dimension&lt;4&gt; point_dim;</div><div class="line">                gt::dimension&lt;5&gt; coord_dim;</div><div class="line">                gt::dimension&lt;4&gt; dof1;</div><div class="line">                gt::dimension&lt;5&gt; dof2;</div><div class="line"></div><div class="line">                constexpr gt::meta_storage_base&lt;static_int&lt;__COUNTER__&gt;,gt::layout_map&lt;2,1,0&gt;,<span class="keyword">false</span>&gt; indexing{N_DOF0,N_DOF1,N_DOF2};</div><div class="line">                uint_t <span class="keyword">const</span> num_dof=eval.template get_storage_dim&lt;4&gt;(stiff());</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span>(short_t I1=0; I1&lt;indexing.template dim&lt;0&gt;(); I1++)</div><div class="line">                    <span class="keywordflow">for</span>(short_t J1=0; J1&lt;indexing.template dim&lt;1&gt;(); J1++)</div><div class="line">                        <span class="keywordflow">for</span>(short_t i=0; i&lt;num_dof; i++) {</div><div class="line">                            eval(stiff(dof1+indexing.index(J1,N_DOF1-1,I1),dof2+i)) = 0.;</div><div class="line">                            eval(stiff(dof2+indexing.index(J1,N_DOF1-1,I1),dof1+i)) = 0.;</div><div class="line">                        }</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span>(short_t I1=0; I1&lt;indexing.template dim&lt;0&gt;(); I1++)</div><div class="line">                    <span class="keywordflow">for</span>(short_t J1=0; J1&lt;indexing.template dim&lt;1&gt;(); J1++)</div><div class="line">                    {</div><div class="line">                        eval(stiff(dof1+indexing.index(J1,N_DOF1-1,I1),dof2+indexing.index(J1,N_DOF1-1,I1))) = 1.;</div><div class="line"></div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> x = eval(grid_points(point_dim+indexing.index(J1,N_DOF1-1,I1),coord_dim+0));</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> y = eval(grid_points(point_dim+indexing.index(J1,N_DOF1-1,I1),coord_dim+1));</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> z = eval(grid_points(point_dim+indexing.index(J1,N_DOF1-1,I1),coord_dim+2));</div><div class="line"></div><div class="line">                        eval(source(dof1+indexing.index(J1,N_DOF1-1,I1))) = BoundaryFunctionDefinition::compute(x,y,z);</div><div class="line"></div><div class="line">                    }</div><div class="line">            }</div><div class="line">        };</div><div class="line"></div><div class="line">        <span class="keyword">template</span> &lt;u<span class="keywordtype">short</span>_t N_DOF0, u<span class="keywordtype">short</span>_t N_DOF1, u<span class="keywordtype">short</span>_t N_DOF2, <span class="keyword">typename</span> BoundaryFunctionDefinition&gt;</div><div class="line">        <span class="keyword">struct </span>apply_dirichlet_boundary_conditions_left {</div><div class="line"></div><div class="line">            <span class="keyword">using</span> grid_points=gt::accessor&lt;0, enumtype::in, gt::extent&lt;0,0,0,0&gt; , 5&gt; <span class="keyword">const</span>;</div><div class="line">            <span class="keyword">using</span> stiff=gt::accessor&lt;1, enumtype::inout, gt::extent&lt;0,0,0,0&gt; , 5&gt; ;</div><div class="line">            <span class="keyword">using</span> source=gt::accessor&lt;2, enumtype::inout, gt::extent&lt;0,0,0,0&gt; , 4&gt; ;</div><div class="line">            <span class="keyword">using</span> arg_list= boost::mpl::vector&lt;grid_points, stiff, source&gt;;</div><div class="line"></div><div class="line">            <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Evaluation&gt;</div><div class="line">            GT_FUNCTION</div><div class="line">            <span class="keyword">static</span> <span class="keywordtype">void</span> Do(Evaluation <span class="keyword">const</span> &amp; eval, x_interval) {</div><div class="line"></div><div class="line">                gt::dimension&lt;4&gt; point_dim;</div><div class="line">                gt::dimension&lt;5&gt; coord_dim;</div><div class="line">                gt::dimension&lt;4&gt; dof1;</div><div class="line">                gt::dimension&lt;5&gt; dof2;</div><div class="line"></div><div class="line">                constexpr gt::meta_storage_base&lt;static_int&lt;__COUNTER__&gt;,gt::layout_map&lt;2,1,0&gt;,<span class="keyword">false</span>&gt; indexing{N_DOF0,N_DOF1,N_DOF2};</div><div class="line">                uint_t <span class="keyword">const</span> num_dof=eval.template get_storage_dim&lt;4&gt;(stiff());</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span>(short_t I1=0; I1&lt;indexing.template dim&lt;0&gt;(); I1++)</div><div class="line">                    <span class="keywordflow">for</span>(short_t J1=0; J1&lt;indexing.template dim&lt;1&gt;(); J1++)</div><div class="line">                        <span class="keywordflow">for</span>(short_t i=0; i&lt;num_dof; i++) {</div><div class="line">                            eval(stiff(dof1+indexing.index(0,J1,I1),dof2+i)) = 0.;</div><div class="line">                            eval(stiff(dof2+indexing.index(0,J1,I1),dof1+i)) = 0.;</div><div class="line">                        }</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span>(short_t I1=0; I1&lt;indexing.template dim&lt;0&gt;(); I1++)</div><div class="line">                    <span class="keywordflow">for</span>(short_t J1=0; J1&lt;indexing.template dim&lt;1&gt;(); J1++)</div><div class="line">                    {</div><div class="line">                        eval(stiff(dof1+indexing.index(0,J1,I1),dof2+indexing.index(0,J1,I1))) = 1.;</div><div class="line"></div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> x = eval(grid_points(point_dim+indexing.index(0,J1,I1),coord_dim+0));</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> y = eval(grid_points(point_dim+indexing.index(0,J1,I1),coord_dim+1));</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> z = eval(grid_points(point_dim+indexing.index(0,J1,I1),coord_dim+2));</div><div class="line"></div><div class="line">                        eval(source(dof1+indexing.index(0,J1,I1))) = BoundaryFunctionDefinition::compute(x,y,z);</div><div class="line">                    }</div><div class="line">            }</div><div class="line">        };</div><div class="line"></div><div class="line">        <span class="keyword">template</span> &lt;u<span class="keywordtype">short</span>_t N_DOF0, u<span class="keywordtype">short</span>_t N_DOF1, u<span class="keywordtype">short</span>_t N_DOF2, <span class="keyword">typename</span> BoundaryFunctionDefinition&gt;</div><div class="line">        <span class="keyword">struct </span>apply_dirichlet_boundary_conditions_right {</div><div class="line"></div><div class="line">            <span class="keyword">using</span> grid_points=gt::accessor&lt;0, enumtype::in, gt::extent&lt;0,0,0,0&gt; , 5&gt; <span class="keyword">const</span>;</div><div class="line">            <span class="keyword">using</span> stiff=gt::accessor&lt;1, enumtype::inout, gt::extent&lt;0,0,0,0&gt; , 5&gt; ;</div><div class="line">            <span class="keyword">using</span> source=gt::accessor&lt;2, enumtype::inout, gt::extent&lt;0,0,0,0&gt; , 4&gt; ;</div><div class="line">            <span class="keyword">using</span> arg_list= boost::mpl::vector&lt;grid_points, stiff, source&gt;;</div><div class="line"></div><div class="line">            <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Evaluation&gt;</div><div class="line">            GT_FUNCTION</div><div class="line">            <span class="keyword">static</span> <span class="keywordtype">void</span> Do(Evaluation <span class="keyword">const</span> &amp; eval, x_interval) {</div><div class="line"></div><div class="line">                gt::dimension&lt;4&gt; point_dim;</div><div class="line">                gt::dimension&lt;5&gt; coord_dim;</div><div class="line">                gt::dimension&lt;4&gt; dof1;</div><div class="line">                gt::dimension&lt;5&gt; dof2;</div><div class="line"></div><div class="line">                constexpr gt::meta_storage_base&lt;static_int&lt;__COUNTER__&gt;,gt::layout_map&lt;2,1,0&gt;,<span class="keyword">false</span>&gt; indexing{N_DOF0,N_DOF1,N_DOF2};</div><div class="line">                uint_t <span class="keyword">const</span> num_dof=eval.template get_storage_dim&lt;4&gt;(stiff());</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span>(short_t I1=0; I1&lt;indexing.template dim&lt;0&gt;(); I1++)</div><div class="line">                    <span class="keywordflow">for</span>(short_t J1=0; J1&lt;indexing.template dim&lt;1&gt;(); J1++)</div><div class="line">                        <span class="keywordflow">for</span>(short_t i=0; i&lt;num_dof; i++) {</div><div class="line">                            eval(stiff(dof1+indexing.index(N_DOF2-1,J1,I1),dof2+i)) = 0.;</div><div class="line">                            eval(stiff(dof2+indexing.index(N_DOF2-1,J1,I1),dof1+i)) = 0.;</div><div class="line">                        }</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span>(short_t I1=0; I1&lt;indexing.template dim&lt;0&gt;(); I1++)</div><div class="line">                    <span class="keywordflow">for</span>(short_t J1=0; J1&lt;indexing.template dim&lt;1&gt;(); J1++)</div><div class="line">                    {</div><div class="line">                        eval(stiff(dof1+indexing.index(N_DOF2-1,J1,I1),dof2+indexing.index(N_DOF2-1,J1,I1))) = 1.;</div><div class="line"></div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> x = eval(grid_points(point_dim+indexing.index(N_DOF2-1,J1,I1),coord_dim+0));</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> y = eval(grid_points(point_dim+indexing.index(N_DOF2-1,J1,I1),coord_dim+1));</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> z = eval(grid_points(point_dim+indexing.index(N_DOF2-1,J1,I1),coord_dim+2));</div><div class="line"></div><div class="line">                        eval(source(dof1+indexing.index(N_DOF2-1,J1,I1))) = BoundaryFunctionDefinition::compute(x,y,z);</div><div class="line">                    }</div><div class="line">            }</div><div class="line">        };</div><div class="line"></div><div class="line">        <span class="keyword">template</span> &lt;u<span class="keywordtype">short</span>_t N_DOF0, u<span class="keywordtype">short</span>_t N_DOF1, u<span class="keywordtype">short</span>_t N_DOF2, <span class="keyword">typename</span> BoundaryFunctionDefinition&gt;</div><div class="line">        <span class="keyword">struct </span>apply_dirichlet_boundary_conditions_front {</div><div class="line"></div><div class="line"></div><div class="line">            <span class="keyword">using</span> grid_points=gt::accessor&lt;0, enumtype::in, gt::extent&lt;0,0,0,0&gt; , 5&gt; <span class="keyword">const</span>;</div><div class="line">            <span class="keyword">using</span> stiff=gt::accessor&lt;1, enumtype::inout, gt::extent&lt;0,0,0,0&gt; , 5&gt; ;</div><div class="line">            <span class="keyword">using</span> source=gt::accessor&lt;2, enumtype::inout, gt::extent&lt;0,0,0,0&gt; , 4&gt; ;</div><div class="line">            <span class="keyword">using</span> arg_list= boost::mpl::vector&lt;grid_points, stiff, source&gt;;</div><div class="line"></div><div class="line">            <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Evaluation&gt;</div><div class="line">            GT_FUNCTION</div><div class="line">            <span class="keyword">static</span> <span class="keywordtype">void</span> Do(Evaluation <span class="keyword">const</span> &amp; eval, x_interval) {</div><div class="line"></div><div class="line">                gt::dimension&lt;4&gt; point_dim;</div><div class="line">                gt::dimension&lt;5&gt; coord_dim;</div><div class="line">                gt::dimension&lt;4&gt; dof1;</div><div class="line">                gt::dimension&lt;5&gt; dof2;</div><div class="line"></div><div class="line">                constexpr gt::meta_storage_base&lt;static_int&lt;__COUNTER__&gt;,gt::layout_map&lt;2,1,0&gt;,<span class="keyword">false</span>&gt; indexing{N_DOF0,N_DOF1,N_DOF2};</div><div class="line">                uint_t <span class="keyword">const</span> num_dof=eval.template get_storage_dim&lt;4&gt;(stiff());</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span>(short_t I1=0; I1&lt;indexing.template dim&lt;0&gt;(); I1++)</div><div class="line">                    <span class="keywordflow">for</span>(short_t J1=0; J1&lt;indexing.template dim&lt;1&gt;(); J1++)</div><div class="line">                        <span class="keywordflow">for</span>(short_t i=0; i&lt;num_dof; i++) {</div><div class="line">                          eval(stiff(dof1+indexing.index(J1,I1,0),dof2+i)) = 0.;</div><div class="line">                          eval(stiff(dof2+indexing.index(J1,I1,0),dof1+i)) = 0.;</div><div class="line">                        }</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span>(short_t I1=0; I1&lt;indexing.template dim&lt;0&gt;(); I1++)</div><div class="line">                    <span class="keywordflow">for</span>(short_t J1=0; J1&lt;indexing.template dim&lt;1&gt;(); J1++)</div><div class="line">                    {</div><div class="line">                        eval(stiff(dof1+indexing.index(J1,I1,0),dof2+indexing.index(J1,I1,0))) = 1.;</div><div class="line"></div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> x = eval(grid_points(point_dim+indexing.index(J1,I1,0),coord_dim+0));</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> y = eval(grid_points(point_dim+indexing.index(J1,I1,0),coord_dim+1));</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> z = eval(grid_points(point_dim+indexing.index(J1,I1,0),coord_dim+2));</div><div class="line"></div><div class="line">                        eval(source(dof1+indexing.index(J1,I1,0))) = BoundaryFunctionDefinition::compute(x,y,z);</div><div class="line">                    }</div><div class="line">            }</div><div class="line">        };</div><div class="line"></div><div class="line">        <span class="keyword">template</span> &lt;u<span class="keywordtype">short</span>_t N_DOF0, u<span class="keywordtype">short</span>_t N_DOF1, u<span class="keywordtype">short</span>_t N_DOF2, <span class="keyword">typename</span> BoundaryFunctionDefinition&gt;</div><div class="line">        <span class="keyword">struct </span>apply_dirichlet_boundary_conditions_rear {</div><div class="line"></div><div class="line">            <span class="keyword">using</span> grid_points=gt::accessor&lt;0, enumtype::in, gt::extent&lt;0,0,0,0&gt; , 5&gt; <span class="keyword">const</span>;</div><div class="line">            <span class="keyword">using</span> stiff=gt::accessor&lt;1, enumtype::inout, gt::extent&lt;0,0,0,0&gt; , 5&gt; ;</div><div class="line">            <span class="keyword">using</span> source=gt::accessor&lt;2, enumtype::inout, gt::extent&lt;0,0,0,0&gt; , 4&gt; ;</div><div class="line">            <span class="keyword">using</span> arg_list= boost::mpl::vector&lt;grid_points, stiff, source&gt;;</div><div class="line"></div><div class="line">            <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Evaluation&gt;</div><div class="line">            GT_FUNCTION</div><div class="line">            <span class="keyword">static</span> <span class="keywordtype">void</span> Do(Evaluation <span class="keyword">const</span> &amp; eval, x_interval) {</div><div class="line"></div><div class="line">                gt::dimension&lt;4&gt; point_dim;</div><div class="line">                gt::dimension&lt;5&gt; coord_dim;</div><div class="line">                gt::dimension&lt;4&gt; dof1;</div><div class="line">                gt::dimension&lt;5&gt; dof2;</div><div class="line"></div><div class="line">                constexpr gt::meta_storage_base&lt;static_int&lt;__COUNTER__&gt;,gt::layout_map&lt;2,1,0&gt;,<span class="keyword">false</span>&gt; indexing{N_DOF0,N_DOF1,N_DOF2};</div><div class="line">                uint_t <span class="keyword">const</span> num_dof=eval.template get_storage_dim&lt;4&gt;(stiff());</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span>(short_t I1=0; I1&lt;indexing.template dim&lt;0&gt;(); I1++)</div><div class="line">                    <span class="keywordflow">for</span>(short_t J1=0; J1&lt;indexing.template dim&lt;1&gt;(); J1++)</div><div class="line">                        <span class="keywordflow">for</span>(short_t i=0; i&lt;num_dof; i++) {</div><div class="line">                            eval(stiff(dof1+indexing.index(J1,I1,N_DOF0-1),dof2+i)) = 0.;</div><div class="line">                            eval(stiff(dof2+indexing.index(J1,I1,N_DOF0-1),dof1+i)) = 0.;</div><div class="line">                        }</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span>(short_t I1=0; I1&lt;indexing.template dim&lt;0&gt;(); I1++)</div><div class="line">                    <span class="keywordflow">for</span>(short_t J1=0; J1&lt;indexing.template dim&lt;1&gt;(); J1++)</div><div class="line">                    {</div><div class="line">                        eval(stiff(dof1+indexing.index(J1,I1,N_DOF0-1),dof2+indexing.index(J1,I1,N_DOF0-1))) = 1.;</div><div class="line"></div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> x = eval(grid_points(point_dim+indexing.index(J1,I1,N_DOF0-1),coord_dim+0));</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> y = eval(grid_points(point_dim+indexing.index(J1,I1,N_DOF0-1),coord_dim+1));</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> z = eval(grid_points(point_dim+indexing.index(J1,I1,N_DOF0-1),coord_dim+2));</div><div class="line"></div><div class="line">                        eval(source(dof1+indexing.index(J1,I1,N_DOF0-1))) = BoundaryFunctionDefinition::compute(x,y,z);</div><div class="line">                    }</div><div class="line">            }</div><div class="line">        };</div><div class="line"></div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#define PRINT_DATA_FILES true</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a name="a0"></a><a class="code" href="a02981.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>(){</div><div class="line"></div><div class="line">    <span class="comment">// - In this example a Poisson problem in 3D is solved</span></div><div class="line">    <span class="comment">// - Homogeneous Dirichlet boundary conditions are imposed</span></div><div class="line">    <span class="comment">// - The source term is non null and defined according to the implementation of the FunctionDefinition template parameter of function_evaluation functor</span></div><div class="line">    <span class="comment">// - The FEM linear system is solved making use of the Conjugate Gradient method implemented in the cg_solver functor</span></div><div class="line">    <span class="comment">// - NOTE: have a look to the linear_solver example for correct usage of the available linear solver functors</span></div><div class="line">    <span class="comment">// - WARNING: this is a temporary example built to reproduce the results obtained with deal.II for the same problem (have a look to step-4.cc).</span></div><div class="line">    <span class="comment">//   For this reason we need the same dof ordering and this is obtained by using the reordered_grid and by activating the</span></div><div class="line">    <span class="comment">//   REORDER and DEAL_II_ORDERING flag in numerics/intrepid.hpp. At present this only works for order 1 Lagrange elements on Hexahedron so</span></div><div class="line">    <span class="comment">//   do not change this setup (FE choice).</span></div><div class="line">    <span class="comment">// - WARNING: at present the only elements available to the user for modification are the [solver_setup], [domain_definition]</span></div><div class="line">    <span class="comment">//   and [boundary_value] parameters together with the source definition</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> stability_thr(-1.0);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> error_thr(1.e-20);</div><div class="line">    <span class="keywordtype">double</span> stability;</div><div class="line">    uint_t max_iter(10000);</div><div class="line"></div><div class="line">    constexpr uint_t d1=4;</div><div class="line">    constexpr uint_t d2=4;</div><div class="line">    constexpr uint_t d3=4;</div><div class="line"></div><div class="line">    <span class="comment">// WARNING: DO NOT MODIFY ANYTHING BELOW THIS LINE!!!</span></div><div class="line"></div><div class="line">    <span class="keyword">using</span> fe=<a name="_a1"></a><a class="code" href="a04218.html">reference_element&lt;1, Lagrange, Hexa&gt;</a>;</div><div class="line">    <span class="keyword">using</span> geo_map=<a class="code" href="a04218.html">reference_element&lt;1, Lagrange, Hexa&gt;</a>;</div><div class="line">    <span class="keyword">using</span> cub=<a name="_a2"></a><a class="code" href="a04326.html">cubature&lt;2, fe::shape()&gt;</a>;</div><div class="line">    <span class="keyword">using</span> geo_t = <a name="_a3"></a><a class="code" href="a04414.html">intrepid::geometry&lt;geo_map, cub&gt;</a>;</div><div class="line">    <span class="keyword">using</span> discr_t = <a name="_a4"></a><a class="code" href="a04406.html">intrepid::discretization&lt;fe, cub&gt;</a>;</div><div class="line">    <span class="keyword">using</span> as=<a name="_a5"></a><a class="code" href="a04158.html">assembly&lt;geo_t&gt;</a>;</div><div class="line">    <span class="keyword">using</span> as_base=<a name="_a6"></a><a class="code" href="a04182.html">assembly_base&lt;geo_t&gt;</a>;</div><div class="line">    constexpr uint_t dof_per_dim{2};<span class="comment">//TODO: compute this information from FEM traits</span></div><div class="line">    constexpr uint_t dof_per_el{dof_per_dim*dof_per_dim*dof_per_dim};<span class="comment">//TODO: compute this information from FEM traits</span></div><div class="line">    constexpr gridtools::uint_t n_dof{((dof_per_dim-1)*d1+1)*((dof_per_dim-1)*d2+1)*((dof_per_dim-1)*d3+1)};</div><div class="line">    constexpr gridtools::uint_t n_dofx{(dof_per_dim-1)*d1+1};</div><div class="line">    constexpr gridtools::uint_t n_dofy{(dof_per_dim-1)*d2+1};</div><div class="line">    constexpr gridtools::uint_t n_dofz{(dof_per_dim-1)*d3+1};</div><div class="line"></div><div class="line">    <span class="comment">// Stiffness matrix</span></div><div class="line">    <span class="keyword">using</span> stiffness_matrix_storage_info_t=storage_info&lt;  __COUNTER__, layout_tt&lt;5&gt; &gt;;</div><div class="line">    <span class="keyword">using</span> stiffness_matrix_type = gridtools::storage&lt;assemble_storage&lt; stiffness_matrix_storage_info_t, dof_per_dim, dof_per_dim, dof_per_dim&gt; &gt;;<span class="comment">//TODO: default storage needed (unassembled content)</span></div><div class="line">    <span class="comment">// Source vector (source values at cubature points)</span></div><div class="line">    <span class="keyword">using</span> source_vector_storage_info_t=storage_info&lt;  __COUNTER__, layout_tt&lt;4&gt; &gt;;</div><div class="line">    <span class="keyword">using</span> source_vector_type = gridtools::storage&lt;assemble_storage&lt; source_vector_storage_info_t, dof_per_dim, dof_per_dim, dof_per_dim&gt; &gt;;<span class="comment">//TODO: default storage needed (unassembled content)</span></div><div class="line">    <span class="comment">// Interpolated source vector (source interpolated on basis functions)</span></div><div class="line">    <span class="keyword">using</span> interpolated_source_vector_storage_info_t=storage_info&lt;  __COUNTER__, layout_tt&lt;4&gt; &gt;;</div><div class="line">    <span class="keyword">using</span> interpolated_source_vector_type = gridtools::storage&lt;assemble_storage&lt; interpolated_source_vector_storage_info_t, dof_per_dim, dof_per_dim, dof_per_dim&gt; &gt;;<span class="comment">//TODO: default storage needed (unassembled content)</span></div><div class="line">    <span class="comment">// Source evaluation grid</span></div><div class="line">    <span class="keyword">using</span> source_evaluation_grid_storage_info_t=storage_info&lt;  __COUNTER__, layout_tt&lt;5&gt; &gt;;</div><div class="line">    <span class="keyword">using</span> source_evaluation_grid_type = storage_t&lt;source_evaluation_grid_storage_info_t&gt;;</div><div class="line">    <span class="comment">// Solution vector</span></div><div class="line">    <span class="keyword">using</span> solution_vector_storage_info_t=storage_info&lt; __COUNTER__, layout_tt&lt;4&gt; &gt;;</div><div class="line">    <span class="keyword">using</span> solution_vector_type = gridtools::storage&lt;assemble_storage&lt; solution_vector_storage_info_t, dof_per_dim, dof_per_dim, dof_per_dim&gt; &gt;;</div><div class="line"></div><div class="line">    constexpr uint_t ass_d1{d1+1};</div><div class="line">    constexpr uint_t ass_d2{d2+1};</div><div class="line">    constexpr uint_t ass_d3{d3+1};</div><div class="line">    <span class="comment">// Computational domain: this is the domain used for linear system solution calculation namely the physical domain plus a 1 element halo (along all domain boundary faces)</span></div><div class="line">    constexpr uint_t comp_d1{d1+2};</div><div class="line">    constexpr uint_t comp_d2{d2+2};</div><div class="line">    constexpr uint_t comp_d3{d3+2};</div><div class="line">    <span class="comment">// Stiffness matrix</span></div><div class="line">    stiffness_matrix_storage_info_t stiffness_(comp_d1,comp_d2,comp_d3,dof_per_el,dof_per_el);</div><div class="line">    stiffness_matrix_type stiffness(stiffness_, <a name="_a7"></a><a class="code" href="a04126.html">halo_data</a>(2,2,2,1,1,1), 0.e0, <span class="stringliteral">&quot;stiffness&quot;</span>);<span class="comment">// This is the unassembled problem matrix</span></div><div class="line">    <span class="comment">// Source vector (source values at cubature points)</span></div><div class="line">    source_vector_storage_info_t source_values_(comp_d1,comp_d2,comp_d3,cub::numCubPoints());</div><div class="line">    source_vector_type source_values(source_values_, <a class="code" href="a04126.html">halo_data</a>(2,2,2,1,1,1), 0.e0, <span class="stringliteral">&quot;source_values&quot;</span>);<span class="comment">// These are the source values computed at cubature point of each mesh element</span></div><div class="line">    <span class="comment">// Interpolated source vector (source interpolated on basis functions)</span></div><div class="line">    interpolated_source_vector_storage_info_t interpolated_source_(comp_d1,comp_d2,comp_d3,dof_per_el);</div><div class="line">    interpolated_source_vector_type interpolated_source(interpolated_source_, <a class="code" href="a04126.html">halo_data</a>(2,2,2,1,1,1), 0.e0, <span class="stringliteral">&quot;interpolated source&quot;</span>);<span class="comment">// This is the unassembled right hand side vector</span></div><div class="line">    <span class="comment">// Source evaluation grid</span></div><div class="line">    source_evaluation_grid_storage_info_t source_evaluation_grid_(ass_d1,ass_d2,ass_d3,cub::numCubPoints(),3);</div><div class="line">    source_evaluation_grid_type source_evaluation_grid(source_evaluation_grid_,0,<span class="stringliteral">&quot;source_evaluation_grid&quot;</span>);<span class="comment">// This is the grid of cubature points on which the source is evaluated</span></div><div class="line">    <span class="comment">// Solution vector</span></div><div class="line">    solution_vector_storage_info_t sol_(comp_d1,comp_d2,comp_d3,dof_per_el);</div><div class="line">    solution_vector_type sol(sol_, <a class="code" href="a04126.html">halo_data</a>(2,2,2,1,1,1), 0.e0, <span class="stringliteral">&quot;sol&quot;</span>);<span class="comment">// This is the assembled unknowns vector</span></div><div class="line"><span class="comment"></span></div><div class="line">    <span class="keyword">auto</span> ass_with_halo_coords=gridtools::grid&lt;axis&gt;({1, 0, 1, ass_d1-1, ass_d1},</div><div class="line">      {1, 0, 1, ass_d2-1, ass_d2});</div><div class="line">    ass_with_halo_coords.value_list[0] = 1;</div><div class="line">    ass_with_halo_coords.value_list[1] = ass_d3-1;</div><div class="line"></div><div class="line">    geo_t geo_;</div><div class="line">    discr_t fe_;</div><div class="line">    geo_.<a name="a8"></a><a class="code" href="a04406.html#a79fd100ccc3f922a503fbbfd16c83891">compute</a>(Intrepid::OPERATOR_GRAD);<span class="comment">//redundants</span></div><div class="line">    <span class="comment">//    geo_.compute(Intrepid::OPERATOR_VALUE);</span></div><div class="line">    fe_.compute(Intrepid::OPERATOR_GRAD);</div><div class="line">    fe_.compute(Intrepid::OPERATOR_VALUE);</div><div class="line">    <span class="keyword">using</span> as=<a class="code" href="a04158.html">assembly&lt;geo_t&gt;</a>;</div><div class="line">    <span class="keyword">using</span> as_base=<a class="code" href="a04182.html">assembly_base&lt;geo_t&gt;</a>;</div><div class="line">    as assembler( geo_, ass_d1, ass_d2, ass_d3);</div><div class="line">    as_base assembler_base(ass_d1, ass_d2, ass_d3);</div><div class="line"></div><div class="line">    <span class="comment">//constructing a structured cartesian grid</span></div><div class="line">    <span class="keywordflow">for</span> (uint_t i=0; i&lt;ass_d1; i++)</div><div class="line">        <span class="keywordflow">for</span> (uint_t j=0; j&lt;ass_d2; j++)</div><div class="line">            <span class="keywordflow">for</span> (uint_t k=0; k&lt;ass_d3; k++){</div><div class="line">                <span class="keywordflow">for</span> (uint_t point=0; point&lt;geo_map::basis_cardinality(); point++)</div><div class="line">                {</div><div class="line">                    <span class="comment">// TODO: here we use the reordered_grid method in order to have the same dof ordering of deal.II</span></div><div class="line">                    assembler_base.grid()( i,  j,  k,  point,  0)= (2*i + geo_.reordered_grid()(point, 0, 0) - 1.);</div><div class="line">                    assembler_base.grid()( i,  j,  k,  point,  1)= (2*j + geo_.reordered_grid()(point, 1, 0) - 1.);</div><div class="line">                    assembler_base.grid()( i,  j,  k,  point,  2)= (2*k + geo_.reordered_grid()(point, 2, 0) - 1.);</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">    <span class="comment">// In this part we compute the source term of the FEM linear system, performed in the following steps:</span></div><div class="line">    <span class="comment">// 1) generation of the grid of cubature points on the mesh elements, starting from the cubature points of the reference element</span></div><div class="line">    <span class="comment">// 2) evaluation of the source function on the generated cubature point grid</span></div><div class="line">    <span class="comment">// 3) calculation of the integrals between source function and basis functions, for all mesh elements</span></div><div class="line"></div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;0, as_base::grid_type&gt; p_grid_points_src;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;1, typename discr_t::basis_function_storage_t&gt; p_phi_src;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;2, source_evaluation_grid_type&gt; p_source_evaluation_grid_src;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;3, source_vector_type&gt; p_source_values_src;</div><div class="line"></div><div class="line">    <span class="keyword">typedef</span> boost::mpl::vector&lt;p_grid_points_src,p_phi_src,p_source_evaluation_grid_src,p_source_values_src&gt; source_eval_domain_accessors;</div><div class="line">    gt::aggregator_type&lt;source_eval_domain_accessors&gt; source_eval_domain(boost::fusion::make_vector(&amp;assembler_base.grid(),</div><div class="line">                                                                                                    &amp;fe_.val(),</div><div class="line">                                                                                                    &amp;source_evaluation_grid,</div><div class="line">                                                                                                    &amp;source_values));</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> source_eval=gt::make_computation&lt;BACKEND&gt;(source_eval_domain,</div><div class="line">                                                   ass_with_halo_coords,</div><div class="line">                                                   make_multistage(</div><div class="line">                                                       execute&lt;forward&gt;(),</div><div class="line">                                                       gt::make_stage&lt;<a name="_a9"></a><a class="code" href="a03810.html">gdl::functors::cubature_point_grid_generation&lt;geo_t&gt;</a> &gt;(</div><div class="line">                                                           p_grid_points_src(),</div><div class="line">                                                           p_phi_src(),</div><div class="line">                                                           p_source_evaluation_grid_src()),</div><div class="line">                                                       gt::make_stage&lt;<a name="_a10"></a><a class="code" href="a03814.html">gdl::functors::function_evaluation&lt;gdl::functors::quartic_source&gt;</a> &gt;(</div><div class="line">                                                           p_source_evaluation_grid_src(),</div><div class="line">                                                           p_source_values_src())</div><div class="line">                                                                   ));</div><div class="line">    source_eval-&gt;ready();</div><div class="line">    source_eval-&gt;steady();</div><div class="line">    source_eval-&gt;run();</div><div class="line">    source_eval-&gt;finalize();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;0, as_base::grid_type&gt; p_grid_points_interp;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;1, discr_t::grad_storage_t&gt; p_dphi_interp;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;2, as::jacobian_type&gt; p_jac_interp;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;3, as::storage_type&gt; p_jac_det_interp;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;4, as::weights_storage_t&gt; p_weights_interp;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;5, typename discr_t::basis_function_storage_t&gt; p_phi_interp;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;6, source_vector_type&gt; p_source_values_interp;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;7, interpolated_source_vector_type&gt; p_interpolated_source_values_interp;</div><div class="line"></div><div class="line">    <span class="keyword">typedef</span> boost::mpl::vector&lt;p_grid_points_interp, p_dphi_interp, p_jac_interp, p_jac_det_interp, p_weights_interp, p_phi_interp, p_source_values_interp, p_interpolated_source_values_interp&gt; source_interp_domain_accessors;</div><div class="line">    gt::aggregator_type&lt;source_interp_domain_accessors&gt; source_interp_domain(boost::fusion::make_vector(&amp;assembler_base.grid(),</div><div class="line">                                                                                                        &amp;fe_.grad(),</div><div class="line">                                                                                                        &amp;assembler.jac(),</div><div class="line">                                                                                                        &amp;assembler.jac_det(),</div><div class="line">                                                                                                        &amp;assembler.cub_weights(),</div><div class="line">                                                                                                        &amp;fe_.val(),</div><div class="line">                                                                                                        &amp;source_values,</div><div class="line">                                                                                                        &amp;interpolated_source));</div><div class="line"></div><div class="line">    <span class="comment">// TODO: merge step 1-2-3</span></div><div class="line">    <span class="keyword">auto</span> source_interp=gt::make_computation&lt;BACKEND&gt;(source_interp_domain,</div><div class="line">                                                     ass_with_halo_coords,</div><div class="line">                                                     gridtools::make_multistage(</div><div class="line">                                                         gridtools::enumtype::execute&lt;gridtools::enumtype::forward&gt;(),</div><div class="line">                                                         gt::make_stage&lt;<a name="_a11"></a><a class="code" href="a03862.html">gdl::functors::update_jac&lt;geo_t&gt;</a> &gt;( p_grid_points_interp(), p_dphi_interp(), p_jac_interp()),</div><div class="line">                                                         gt::make_stage&lt;<a name="_a12"></a><a class="code" href="a03870.html">gdl::functors::det&lt;geo_t&gt;</a> &gt;(p_jac_interp(), p_jac_det_interp()),</div><div class="line">                                                         gridtools::make_stage&lt;gdl::functors::not_normalized_transform&gt;(p_jac_det_interp(), p_weights_interp(), p_phi_interp(), p_source_values_interp(), p_interpolated_source_values_interp())</div><div class="line">                                                                                ));</div><div class="line">    source_interp-&gt;ready();</div><div class="line">    source_interp-&gt;steady();</div><div class="line">    source_interp-&gt;run();</div><div class="line">    source_interp-&gt;finalize();</div><div class="line"></div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;0, discr_t::grad_storage_t&gt; p_dphi;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;1, discr_t::grad_storage_t&gt; p_dpsi;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;2, as::jacobian_type&gt; p_jac;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;3, as::storage_type&gt; p_jac_det;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;4, as::jacobian_type&gt; p_jac_inv;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;5, as::weights_storage_t&gt; p_weights;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;6, stiffness_matrix_type&gt; p_stiffness;</div><div class="line"></div><div class="line">    <span class="keyword">typedef</span> boost::mpl::vector&lt;p_dphi, p_dpsi, p_jac, p_jac_det, p_jac_inv, p_weights, p_stiffness&gt; stiffness_calculation_domain_accessors;</div><div class="line">    gridtools::aggregator_type&lt;stiffness_calculation_domain_accessors&gt; stiffness_calculation_domain(boost::fusion::make_vector(&amp;fe_.grad(),</div><div class="line">                                                                                                                               &amp;fe_.grad(),</div><div class="line">                                                                                                                               &amp;assembler.jac(),</div><div class="line">                                                                                                                               &amp;assembler.jac_det(),</div><div class="line">                                                                                                                               &amp;assembler.jac_inv(),</div><div class="line">                                                                                                                               &amp;assembler.cub_weights(),</div><div class="line">                                                                                                                               &amp;stiffness));</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> compute_stiffness=gt::make_computation&lt;BACKEND&gt;(</div><div class="line">        stiffness_calculation_domain,</div><div class="line">        ass_with_halo_coords,</div><div class="line">        make_multistage(</div><div class="line">            execute&lt;forward&gt;(),</div><div class="line">            gt::make_stage&lt;<a name="_a13"></a><a class="code" href="a03886.html">gdl::functors::inv&lt;geo_t&gt;</a> &gt;(p_jac(), p_jac_det(), p_jac_inv()),</div><div class="line">            gt::make_stage&lt;<a name="_a14"></a><a class="code" href="a04054.html">gdl::functors::stiffness&lt;fe, cub&gt;</a> &gt;(p_jac_det(), p_jac_inv(), p_weights(), p_dphi(), p_dpsi(), p_stiffness())<span class="comment">//stiffness</span></div><div class="line">        ));</div><div class="line">    compute_stiffness-&gt;ready();</div><div class="line">    compute_stiffness-&gt;steady();</div><div class="line">    compute_stiffness-&gt;run();</div><div class="line">    compute_stiffness-&gt;finalize();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// IMPORTANT NOTE: here we introduce the Dirichlet boundary conditions, by requiring to the solution to have a given value on the domain boundary. With an assembled</span></div><div class="line">    <span class="comment">// stiffness matrix and source vector we would set to 0 all the matrix elements of the rows corresponding to a boundary dof except for the diagonal element, whose value</span></div><div class="line">    <span class="comment">// would be instead set to 1. On the source vector we would then introduce the boundary condition by setting the boundary elements equal to the defined solution values.</span></div><div class="line">    <span class="comment">// In our case we have unassembled stiffness matrix and source vector, however the same strategy works: introducing the above modifications to the local stifness matrices</span></div><div class="line">    <span class="comment">// and source vectors we look for the solution of a linear system identical to the one of the assembled case except for a multiplicative factor for the rows corresponding</span></div><div class="line">    <span class="comment">// to the boundary dofs, the factor value being equal to the number of mesh elements sharing the dof itself. Since this factor, for a given row, is the same for the</span></div><div class="line">    <span class="comment">// stiffness matrix and the source vector the problem solution does not change.</span></div><div class="line"></div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;0, as_base::grid_type&gt; p_grid_points_bc;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;1, stiffness_matrix_type&gt; p_stiffness_bc;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;2, interpolated_source_vector_type&gt; p_interpolated_source_bc;</div><div class="line"></div><div class="line">    <span class="keyword">typedef</span> boost::mpl::vector&lt;p_grid_points_bc,p_stiffness_bc,p_interpolated_source_bc&gt; bc_application_domain_accessors;</div><div class="line">    gridtools::aggregator_type&lt;bc_application_domain_accessors&gt; bc_application_domain(boost::fusion::make_vector(&amp;assembler_base.grid(),&amp;stiffness,&amp;interpolated_source));</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// TODO: rename front/rear/etc with coords xy,z=0, etc</span></div><div class="line">    <span class="comment">// TODO: avoid multiple declaration of stencils and grids</span></div><div class="line"></div><div class="line">    <span class="comment">// Top boundary</span></div><div class="line"><span class="comment"></span>    <span class="keyword">auto</span> bc_application_domain_coords_top=gridtools::grid&lt;axis&gt;({1, 0, 1, ass_d1-1, ass_d1},</div><div class="line">      {1, 0, 1, 1, 2});</div><div class="line">    bc_application_domain_coords_top.value_list[0] = 1;</div><div class="line">    bc_application_domain_coords_top.value_list[1] = ass_d3-1;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> apply_bc_top=gt::make_computation&lt;BACKEND&gt;(</div><div class="line">        bc_application_domain,</div><div class="line">        bc_application_domain_coords_top,</div><div class="line">        make_multistage(</div><div class="line">            execute&lt;forward&gt;(),</div><div class="line">            gt::make_stage&lt;<a name="_a15"></a><a class="code" href="a03830.html">gdl::functors::apply_dirichlet_boundary_conditions_top&lt;dof_per_dim, dof_per_dim, dof_per_dim,gdl::functors::quadratic_boundary_value&gt;</a> &gt;(p_grid_points_bc(),p_stiffness_bc(),p_interpolated_source_bc())</div><div class="line">        ));</div><div class="line">    apply_bc_top-&gt;ready();</div><div class="line">    apply_bc_top-&gt;steady();</div><div class="line">    apply_bc_top-&gt;run();</div><div class="line">    apply_bc_top-&gt;finalize();</div><div class="line"></div><div class="line">    <span class="comment">// Bottom boundary</span></div><div class="line"><span class="comment"></span>    <span class="keyword">auto</span> bc_application_domain_coords_bottom=gridtools::grid&lt;axis&gt;({1, 0, 1, ass_d1-1, ass_d1},</div><div class="line">      {1, 0, d2, d2, 2});</div><div class="line">    bc_application_domain_coords_bottom.value_list[0] = 1;</div><div class="line">    bc_application_domain_coords_bottom.value_list[1] = ass_d3-1;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> apply_bc_bottom=gt::make_computation&lt;BACKEND&gt;(</div><div class="line">        bc_application_domain,</div><div class="line">        bc_application_domain_coords_bottom,</div><div class="line">        make_multistage(</div><div class="line">            execute&lt;forward&gt;(),</div><div class="line">            gt::make_stage&lt;<a name="_a16"></a><a class="code" href="a03834.html">gdl::functors::apply_dirichlet_boundary_conditions_bottom&lt;dof_per_dim, dof_per_dim, dof_per_dim,gdl::functors::quadratic_boundary_value&gt;</a> &gt;(p_grid_points_bc(),p_stiffness_bc(),p_interpolated_source_bc())</div><div class="line">        ));</div><div class="line">    apply_bc_bottom-&gt;ready();</div><div class="line">    apply_bc_bottom-&gt;steady();</div><div class="line">    apply_bc_bottom-&gt;run();</div><div class="line">    apply_bc_bottom-&gt;finalize();</div><div class="line"></div><div class="line">    <span class="comment">// Left boundary</span></div><div class="line"><span class="comment"></span>    <span class="keyword">auto</span> bc_application_domain_coords_left=gridtools::grid&lt;axis&gt;({1, 0, 1, 1, 2},</div><div class="line">      {1, 0, 1, ass_d2-1, ass_d2});</div><div class="line">    bc_application_domain_coords_left.value_list[0] = 1;</div><div class="line">    bc_application_domain_coords_left.value_list[1] = ass_d3-1;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> apply_bc_left=gt::make_computation&lt;BACKEND&gt;(</div><div class="line">        bc_application_domain,</div><div class="line">        bc_application_domain_coords_left,</div><div class="line">        make_multistage(</div><div class="line">            execute&lt;forward&gt;(),</div><div class="line">            gt::make_stage&lt;<a name="_a17"></a><a class="code" href="a03838.html">gdl::functors::apply_dirichlet_boundary_conditions_left&lt;dof_per_dim, dof_per_dim, dof_per_dim,gdl::functors::quadratic_boundary_value&gt;</a> &gt;(p_grid_points_bc(),p_stiffness_bc(),p_interpolated_source_bc())</div><div class="line">        ));</div><div class="line">    apply_bc_left-&gt;ready();</div><div class="line">    apply_bc_left-&gt;steady();</div><div class="line">    apply_bc_left-&gt;run();</div><div class="line">    apply_bc_left-&gt;finalize();</div><div class="line"></div><div class="line">    <span class="comment">// Right boundary</span></div><div class="line"><span class="comment"></span>    <span class="keyword">auto</span> bc_application_domain_coords_right=gridtools::grid&lt;axis&gt;({1, 0, d1, d1, 2},</div><div class="line">      {1, 0, 1, ass_d2-1, ass_d2});</div><div class="line">    bc_application_domain_coords_right.value_list[0] = 1;</div><div class="line">    bc_application_domain_coords_right.value_list[1] = ass_d3-1;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> apply_bc_right=gt::make_computation&lt;BACKEND&gt;(</div><div class="line">        bc_application_domain,</div><div class="line">        bc_application_domain_coords_right,</div><div class="line">        make_multistage(</div><div class="line">            execute&lt;forward&gt;(),</div><div class="line">            gt::make_stage&lt;<a name="_a18"></a><a class="code" href="a03842.html">gdl::functors::apply_dirichlet_boundary_conditions_right&lt;dof_per_dim, dof_per_dim, dof_per_dim,gdl::functors::quadratic_boundary_value&gt;</a> &gt;(p_grid_points_bc(),p_stiffness_bc(),p_interpolated_source_bc())</div><div class="line">        ));</div><div class="line">    apply_bc_right-&gt;ready();</div><div class="line">    apply_bc_right-&gt;steady();</div><div class="line">    apply_bc_right-&gt;run();</div><div class="line">    apply_bc_right-&gt;finalize();</div><div class="line"></div><div class="line">    <span class="comment">// Front boundary</span></div><div class="line">    <span class="comment">//[bc_application_domain_coords_front]</span></div><div class="line">    <span class="keyword">auto</span> bc_application_domain_coords_front=gridtools::grid&lt;axis&gt;({1, 0, 1, ass_d1-1, ass_d1},</div><div class="line">      {1, 0, 1, ass_d2-1, ass_d2});</div><div class="line">    bc_application_domain_coords_front.value_list[0] = 1;</div><div class="line">    bc_application_domain_coords_front.value_list[1] = 1;</div><div class="line">    <span class="comment">//[bc_application_domain_coords_front]</span></div><div class="line"></div><div class="line">    <span class="comment">//[computation]</span></div><div class="line">    <span class="keyword">auto</span> apply_bc_front=gt::make_computation&lt;BACKEND&gt;(</div><div class="line">        bc_application_domain,</div><div class="line">        bc_application_domain_coords_front,</div><div class="line">        make_multistage(</div><div class="line">            execute&lt;forward&gt;(),</div><div class="line">            gt::make_stage&lt;<a name="_a19"></a><a class="code" href="a03846.html">gdl::functors::apply_dirichlet_boundary_conditions_front&lt;dof_per_dim, dof_per_dim, dof_per_dim,gdl::functors::quadratic_boundary_value&gt;</a> &gt;(p_grid_points_bc(),p_stiffness_bc(),p_interpolated_source_bc())</div><div class="line">        ));</div><div class="line">    apply_bc_front-&gt;ready();</div><div class="line">    apply_bc_front-&gt;steady();</div><div class="line">    apply_bc_front-&gt;run();</div><div class="line">    apply_bc_front-&gt;finalize();</div><div class="line">    <span class="comment">//[computation]</span></div><div class="line"></div><div class="line">    <span class="comment">// Rear boundary</span></div><div class="line">    <span class="comment">//[bc_application_domain_coords_rear]</span></div><div class="line">    <span class="keyword">auto</span> bc_application_domain_coords_rear=gridtools::grid&lt;axis&gt;({1, 0, 1, ass_d1-1, ass_d1},</div><div class="line">      {1, 0, 1, ass_d2-1, ass_d2});</div><div class="line">    bc_application_domain_coords_rear.value_list[0] = d3;</div><div class="line">    bc_application_domain_coords_rear.value_list[1] = d3;</div><div class="line">    <span class="comment">//[bc_application_domain_coords_rear]</span></div><div class="line"></div><div class="line">    <span class="comment">//[computation]</span></div><div class="line">    <span class="keyword">auto</span> apply_bc_rear=gt::make_computation&lt;BACKEND&gt;(</div><div class="line">        bc_application_domain,</div><div class="line">        bc_application_domain_coords_rear,</div><div class="line">        make_multistage(</div><div class="line">            execute&lt;forward&gt;(),</div><div class="line">            gt::make_stage&lt;<a name="_a20"></a><a class="code" href="a03850.html">gdl::functors::apply_dirichlet_boundary_conditions_rear&lt;dof_per_dim, dof_per_dim, dof_per_dim,gdl::functors::quadratic_boundary_value&gt;</a> &gt;(p_grid_points_bc(),p_stiffness_bc(),p_interpolated_source_bc())</div><div class="line">        ));</div><div class="line">    apply_bc_rear-&gt;ready();</div><div class="line">    apply_bc_rear-&gt;steady();</div><div class="line">    apply_bc_rear-&gt;run();</div><div class="line">    apply_bc_rear-&gt;finalize();</div><div class="line">    <span class="comment">//[computation]</span></div><div class="line"></div><div class="line">    <span class="comment">//[boundary_condition_application]</span></div><div class="line"></div><div class="line">    <span class="comment">//[linear_system_solution]</span></div><div class="line">    <a name="_a21"></a><a class="code" href="a04446.html">linear_solver&lt; gdl::cg_solver&lt;dof_per_dim, dof_per_dim, dof_per_dim&gt;</a> &gt;::solve(stiffness, interpolated_source, sol, stability_thr, error_thr, max_iter);</div><div class="line">    <span class="comment">//[linear_system_solution]</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#if PRINT_DATA_FILES</span></div><div class="line"></div><div class="line">    <span class="comment">//[print_problem]</span></div><div class="line">    <span class="comment">// In order to compare the obtained linear system and the computed solution with other solver, we perform the assembly of stiffness matrix, source vector and solution vector</span></div><div class="line">    <span class="comment">//[print_storages_definitions]</span></div><div class="line">    <span class="comment">// Stiffness matrix</span></div><div class="line">    <span class="keyword">using</span> assembled_stiffness_matrix_storage_info_t=storage_info&lt;  __COUNTER__, layout_tt&lt;5&gt; &gt;;</div><div class="line">    <span class="keyword">using</span> assembled_stiffness_matrix_type = gridtools::storage&lt;assemble_storage&lt; assembled_stiffness_matrix_storage_info_t, dof_per_dim, dof_per_dim, dof_per_dim&gt; &gt;;<span class="comment">//TODO: default storage needed (unassembled content)</span></div><div class="line">    <span class="comment">// Source vector</span></div><div class="line">    <span class="keyword">using</span> assembled_source_vector_storage_info_t=storage_info&lt;  __COUNTER__, layout_tt&lt;4&gt; &gt;;</div><div class="line">    <span class="keyword">using</span> assembled_source_vector_type = gridtools::storage&lt;assemble_storage&lt; assembled_source_vector_storage_info_t, dof_per_dim, dof_per_dim, dof_per_dim&gt; &gt;;<span class="comment">//TODO: default storage needed (unassembled content)</span></div><div class="line">    <span class="comment">// Solution vector</span></div><div class="line">    <span class="comment">//[print_storages_definitions]</span></div><div class="line"></div><div class="line">    <span class="comment">//[placeholders]</span></div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;0, stiffness_matrix_type&gt; p_unass_stiffness;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;1, stiffness_matrix_type&gt; p_ass_stiffness;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;2, interpolated_source_vector_type&gt; p_unass_source;</div><div class="line">    <span class="keyword">typedef</span> gridtools::arg&lt;3, interpolated_source_vector_type&gt; p_ass_source;</div><div class="line">    <span class="comment">//[placeholders]</span></div><div class="line"></div><div class="line">    <span class="comment">//[domain]</span></div><div class="line">    <span class="keyword">typedef</span> boost::mpl::vector&lt;p_unass_stiffness, p_ass_stiffness, p_unass_source, p_ass_source&gt; ass_domain_accessors;</div><div class="line">    gridtools::aggregator_type&lt;ass_domain_accessors&gt; ass_domain(boost::fusion::make_vector(&amp;stiffness,&amp;stiffness,&amp;interpolated_source,&amp;interpolated_source));</div><div class="line">    <span class="keyword">auto</span> ass_grid=gridtools::grid&lt;axis&gt;({1, 0, 1, interpolated_source.meta_data().template dim&lt;0&gt;()-1, interpolated_source.meta_data().template dim&lt;0&gt;()},</div><div class="line">        {1, 0, 1, interpolated_source.meta_data().template dim&lt;1&gt;()-1, interpolated_source.meta_data().template dim&lt;1&gt;()});</div><div class="line">    ass_grid.value_list[0] = 1;</div><div class="line">    ass_grid.value_list[1] = interpolated_source.meta_data().template dim&lt;2&gt;()-1;</div><div class="line">    <span class="comment">//[domain]</span></div><div class="line"></div><div class="line">    <span class="comment">//[assembly_computation]</span></div><div class="line">    <span class="keyword">auto</span> compute_assemble=gridtools::make_computation&lt;BACKEND&gt;(ass_domain,</div><div class="line">                                                               ass_grid,</div><div class="line">                                                               gridtools::make_multistage(gridtools::enumtype::execute&lt;gridtools::enumtype::forward&gt;(),</div><div class="line">                                                                                          gridtools::make_stage&lt;functors::hexahedron_assemble&lt;dof_per_dim,dof_per_dim,dof_per_dim&gt; &gt;(p_unass_stiffness(),p_ass_stiffness()),</div><div class="line">                                                                                          gridtools::make_stage&lt;functors::hexahedron_matrix_distribute&lt;dof_per_dim,dof_per_dim,dof_per_dim&gt; &gt;(p_ass_stiffness()),</div><div class="line">                                                                                          gridtools::make_stage&lt;functors::hexahedron_vector_assemble&lt;dof_per_dim,dof_per_dim,dof_per_dim&gt; &gt;(p_unass_source(),p_ass_source()),</div><div class="line">                                                                                          gridtools::make_stage&lt;functors::hexahedron_vector_distribute&lt;dof_per_dim,dof_per_dim,dof_per_dim&gt; &gt;(p_ass_source())</div><div class="line">                                                                                    ));</div><div class="line">    compute_assemble-&gt;ready();</div><div class="line">    compute_assemble-&gt;steady();</div><div class="line">    compute_assemble-&gt;run();</div><div class="line">    compute_assemble-&gt;finalize();</div><div class="line">    <span class="comment">//[assembly_computation]</span></div><div class="line"></div><div class="line">    <span class="comment">//[print_lienar_system_on_files]</span></div><div class="line">    std::ofstream A_matrix;</div><div class="line">    A_matrix.open(<span class="stringliteral">&quot;A_matrix.dat&quot;</span>);</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">    for(uint_t dof1 = 0;dof1&lt;n_dof;++dof1){</span></div><div class="line"><span class="comment">        for(uint_t dof2 = 0;dof2&lt;n_dof;++dof2)</span></div><div class="line"><span class="comment">            A_matrix&lt;&lt;(stiffness.get_pointer_to_use())-&gt;get_value(dof1,dof2)&lt;&lt;&quot; &quot;;</span></div><div class="line"><span class="comment">    }</span></div><div class="line"><span class="comment">    */</span></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=1;i&lt;ass_d1;++i)</div><div class="line">      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=1;j&lt;ass_d2;++j)</div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=1;k&lt;ass_d3;++k){</div><div class="line">          A_matrix&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot; &quot;</span>&lt;&lt;j&lt;&lt;<span class="stringliteral">&quot; &quot;</span>&lt;&lt;k&lt;&lt;std::endl;</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span>(uint_t dof1 = 0;dof1&lt;dof_per_el;++dof1){</div><div class="line">              <span class="keywordflow">for</span>(uint_t dof2 = 0;dof2&lt;dof_per_el;++dof2){</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">              <span class="comment">// DOF coords based access</span></div><div class="line">             <span class="comment">//  for(uint_t dof1_z = 0;dof1_z&lt;dof_per_dim;++dof1_z)</span></div><div class="line">             <span class="comment">//  for(uint_t dof1_y = 0;dof1_y&lt;dof_per_dim;++dof1_y)</span></div><div class="line">             <span class="comment">//  for(uint_t dof1_x = 0;dof1_x&lt;dof_per_dim;++dof1_x)</span></div><div class="line">             <span class="comment">//  {</span></div><div class="line"></div><div class="line">             <span class="comment">//  const uint_t dof1 = dof1_x + dof1_y*dof_per_dim + dof1_z*dof_per_dim*dof_per_dim;</span></div><div class="line"></div><div class="line">             <span class="comment">//  for(uint_t dof2_z = 0;dof2_z&lt;dof_per_dim;++dof2_z)</span></div><div class="line">             <span class="comment">//  for(uint_t dof2_y = 0;dof2_y&lt;dof_per_dim;++dof2_y)</span></div><div class="line">             <span class="comment">//  for(uint_t dof2_x = 0;dof2_x&lt;dof_per_dim;++dof2_x){</span></div><div class="line"></div><div class="line">             <span class="comment">//  const uint_t dof2 = dof2_x + dof2_y*dof_per_dim + dof2_z*dof_per_dim*dof_per_dim;</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">                A_matrix&lt;&lt;stiffness(i,j,k,dof1,dof2)&lt;&lt;<span class="stringliteral">&quot; &quot;</span>;</div><div class="line"></div><div class="line">              }</div><div class="line">              A_matrix&lt;&lt;std::endl;</div><div class="line"></div><div class="line">          }</div><div class="line">          A_matrix&lt;&lt;std::endl;</div><div class="line">        }</div><div class="line"></div><div class="line"></div><div class="line">    A_matrix.close();</div><div class="line"></div><div class="line"></div><div class="line">    std::ofstream b_vector;</div><div class="line">    b_vector.open(<span class="stringliteral">&quot;b_vector.dat&quot;</span>);</div><div class="line">    <span class="keywordflow">for</span>(uint_t dof1 = 0;dof1&lt;n_dof;++dof1){</div><div class="line">      <span class="comment">//      b_vector&lt;&lt;(interpolated_source.get_pointer_to_use())-&gt;get_value(dof1)&lt;&lt;&quot; &quot;;</span></div><div class="line">      b_vector&lt;&lt;dof1&lt;&lt;<span class="stringliteral">&quot; &quot;</span>&lt;&lt;(interpolated_source.get_pointer_to_use())-&gt;get_value(dof1)&lt;&lt;std::endl;</div><div class="line">    }</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">    for(int i=1;i&lt;ass_d1;++i)</span></div><div class="line"><span class="comment">      for(int j=1;j&lt;ass_d2;++j)</span></div><div class="line"><span class="comment">        for(int k=1;k&lt;ass_d3;++k){</span></div><div class="line"><span class="comment">          b_vector&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;k&lt;&lt;std::endl;</span></div><div class="line"><span class="comment">          for(uint_t dof1 = 0;dof1&lt;dof_per_el;++dof1){</span></div><div class="line"><span class="comment">            b_vector&lt;&lt;interpolated_source(i,j,k,dof1)&lt;&lt;std::endl;</span></div><div class="line"><span class="comment">          }</span></div><div class="line"><span class="comment">          b_vector&lt;&lt;std::endl;</span></div><div class="line"><span class="comment">        }</span></div><div class="line"><span class="comment">    */</span></div><div class="line">    b_vector.close();</div><div class="line"></div><div class="line">    std::ofstream x_vector;</div><div class="line">    x_vector.open(<span class="stringliteral">&quot;x_vector.dat&quot;</span>);</div><div class="line">    x_vector&lt;&lt;std::setprecision(16);</div><div class="line">    <span class="keywordflow">for</span>(uint_t dof1 = 0;dof1&lt;n_dof;++dof1){</div><div class="line">      <span class="comment">//x_vector&lt;&lt;(sol.get_pointer_to_use())-&gt;get_value(dof1)&lt;&lt;&quot; &quot;;</span></div><div class="line">      x_vector&lt;&lt;dof1&lt;&lt;<span class="stringliteral">&quot; &quot;</span>&lt;&lt;(sol.get_pointer_to_use())-&gt;get_value(dof1)&lt;&lt;std::endl;</div><div class="line">    }</div><div class="line">    x_vector.close();</div><div class="line">    <span class="comment">//[print_lienar_system_on_files]</span></div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">}</div></div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Apr 5 2017 09:06:11 for Galerkin4GT by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.12 </li>
  </ul>
</div>
</body>
</html>
