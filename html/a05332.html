<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Galerkin4GT: Vector Vector Multiplication</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Galerkin4GT
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">Contributive effort to implement proof-of-concept Galerkin methods on new HPC architectures</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a05332.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Vector Vector Multiplication </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this example we will perform an elementwise vector-vector multiplication, corresponding to the following equation </p><div class="fragment"><div class="line">[a_{1},a_{2},a_{3},...,a_{N}]*[b_{1},b_{2},b_{3},...,b_{N}]=[a_{1}*b_{1},a_{2}*b_{2},a_{3}*b_{3},...,a_{N}*b_{N}]</div></div><!-- fragment --><p>The result of this operation is therefore a vector with same size and rank of the operands. Concerning the rank, we will consider 4-dimensional arrays: as already discussed, the first 3 indexes will identify an element within the defined mesh and the last one can be seen as the dof index within a given element.</p>
<p>The steps performed in this example are almost identical to those already discussed in the first one and the reader should refer to it in order to get all the information about the used GridTools and Galerking4GT API.</p>
<p>As in the first example, we start by defining the problem sizes in the following snippet: </p><div class="fragment"><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d1=5;</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d2=5;</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d3=5;</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_rows(10);</div></div><!-- fragment --><p> where d1, d2 and d3 are the mesh sizes in the three space dimensions and where n_rows would correspond to the number of dofs of each mesh element. We then instantiate the vectors as follows </p><div class="fragment"><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    <span class="comment">// vector a</span></div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    <span class="keyword">using</span> vector_a_storage_info_t=gdl::storage_info&lt; __COUNTER__, gdl::layout_tt&lt;4&gt; &gt;;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    <span class="keyword">using</span> vector_a_type=gdl::storage_t&lt; vector_a_storage_info_t &gt;;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    vector_a_storage_info_t v_a_(d1,d2,d3,n_rows);</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    vector_a_type v_a(v_a_, 0.e0, <span class="stringliteral">&quot;v_a&quot;</span>);</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    <span class="comment">// vector b</span></div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <span class="keyword">using</span> vector_b_storage_info_t=gdl::storage_info&lt; __COUNTER__, gdl::layout_tt&lt;4&gt; &gt;;</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    <span class="keyword">using</span> vector_b_type=gdl::storage_t&lt; vector_b_storage_info_t &gt;;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    vector_b_storage_info_t v_b_(d1,d2,d3,n_rows);</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    vector_b_type v_b(v_b_, 0.e0, <span class="stringliteral">&quot;v_b&quot;</span>);</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    <span class="comment">// vector out</span></div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    <span class="keyword">using</span> vector_out_storage_info_t=gdl::storage_info&lt; __COUNTER__, gdl::layout_tt&lt;4&gt; &gt;;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    <span class="keyword">using</span> vector_out_type=gdl::storage_t&lt; vector_out_storage_info_t &gt;;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    vector_out_storage_info_t v_out_(d1,d2,d3,n_rows);</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    vector_out_type v_out(v_out_, 0.e0, <span class="stringliteral">&quot;v_out&quot;</span>);</div></div><!-- fragment --><p> and we assign random values to their elements: </p><div class="fragment"><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    <span class="keywordflow">for</span> (gdl::uint_t i=0; i&lt;d1; i++)</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;        <span class="keywordflow">for</span> (gdl::uint_t j=0; j&lt;d2; j++)</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;            <span class="keywordflow">for</span> (gdl::uint_t k=0; k&lt;d3; k++)</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;                <span class="keywordflow">for</span> (gdl::uint_t row=0; row&lt;n_rows; ++row) {</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;                    v_a(i,j,k,row) = 1.5;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;                    v_b(i,j,k,row) = -1.0;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;                }</div></div><!-- fragment --><p> We then define the size of the GridTools computational domain by instantiating a gridtools::grid&lt;axis&gt; object and providing the sizes as in the following snippet: </p><div class="fragment"><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    <span class="keyword">auto</span> grid=gridtools::grid&lt;axis&gt;({0, 0, 0, d1-1, d1},</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;                                         {0, 0, 0, d2-1, d2});</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    grid.value_list[0] = 0;</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    grid.value_list[1] = d3-1;</div></div><!-- fragment --><p> The next step is the definition of the list of storages to be provided as input parameters to the computational steps involved in this example: we do that by defining a set of placeholder types p_v_a, p_v_b and p_v_out and a placeholder list type accessor_list, containing the placeholders themselves. The defined accessor_list type is then provided as template parameter for the instantiation of an aggregator_type variable domain, as in the following fragment: </p><div class="fragment"><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    <span class="keyword">typedef</span> gdl::gt::arg&lt;0,vector_a_type&gt; p_v_a;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    <span class="keyword">typedef</span> gdl::gt::arg&lt;1,vector_b_type&gt; p_v_b;</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    <span class="keyword">typedef</span> gdl::gt::arg&lt;2,vector_out_type&gt; p_v_out;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    <span class="keyword">typedef</span> boost::mpl::vector&lt;p_v_a, p_v_b, p_v_out&gt; accessor_list;</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    ::gridtools::aggregator_type&lt;accessor_list&gt; domain(boost::fusion::make_vector(&amp;v_a, &amp;v_b, &amp;v_out));</div></div><!-- fragment --><p> In the following snippet we then define the computation tree object: </p><div class="fragment"><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    <span class="keyword">auto</span> compute_mult=::gridtools::make_computation&lt;BACKEND&gt;(domain,</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;        grid,</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;        gridtools::make_multistage(gridtools::enumtype::execute&lt;gridtools::enumtype::forward&gt;(),</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;        gridtools::make_stage&lt; <a class="code" href="a04022.html">gdl::functors::vecvec</a>&lt;4,<a class="code" href="a04010.html">gdl::functors::mult_operator&lt;float_t&gt;</a> &gt; &gt;(p_v_a(),p_v_b(),p_v_out())</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;                   ));</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    compute_mult-&gt;ready();</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    compute_mult-&gt;steady();</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    compute_mult-&gt;run();</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    compute_mult-&gt;finalize();</div><div class="ttc" id="a04022_html"><div class="ttname"><a href="a04022.html">gdl::functors::vecvec</a></div><div class="ttdef"><b>Definition:</b> matvec.hpp:118</div></div>
<div class="ttc" id="a04010_html"><div class="ttname"><a href="a04010.html">gdl::functors::mult_operator</a></div><div class="ttdef"><b>Definition:</b> matvec.hpp:72</div></div>
</div><!-- fragment --><p> As in the previoous case, we have just one computational step corresponding to the calculation of the vector-vector elementwise product. The relative functor is defined as follows: </p><div class="fragment"><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;        <span class="comment">// TODO: these element by element operations could be parallelized avoiding the functor loop</span></div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;        <span class="comment">// Element-wise z = x op y where x, y and z are vectors of the same size</span></div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;        <span class="keyword">template</span> &lt;u<span class="keywordtype">short</span>_t Dim, <span class="keyword">class</span> Operator&gt;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;        <span class="keyword">struct </span>vecvec;</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;        <span class="keyword">template</span> &lt;<span class="keyword">class</span> Operator&gt;</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;        <span class="keyword">struct </span>vecvec&lt;4, Operator&gt; {</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;            <span class="keyword">using</span> in1=gt::accessor&lt;0, enumtype::in, gt::extent&lt;&gt; , 4&gt; ;</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;            <span class="keyword">using</span> in2=gt::accessor&lt;1, enumtype::in, gt::extent&lt;&gt; , 4&gt; ;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;            <span class="keyword">using</span> out=gt::accessor&lt;2, enumtype::inout, gt::extent&lt;&gt; , 4&gt; ;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;            <span class="keyword">using</span> arg_list=boost::mpl::vector&lt; in1, in2, out &gt; ;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;            <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Evaluation&gt;</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;            GT_FUNCTION</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;            <span class="keyword">static</span> <span class="keywordtype">void</span> Do(Evaluation <span class="keyword">const</span> &amp; eval, x_interval) {</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;                gt::dimension&lt;4&gt; row;</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;                <a class="code" href="a04709.html">uint_t</a> <span class="keyword">const</span> num_rows=eval.template get_storage_dim&lt;3&gt;(in1());</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;                <span class="comment">// Loop over vector elements</span></div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;                <span class="keywordflow">for</span>(<a class="code" href="a04709.html">uint_t</a> i=0;i&lt;num_rows;++i){</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;                    eval(out(row+i)) = Operator::eval(eval(in1(row+i)),eval(in2(row+i)));</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;                }</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;            }</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;        };</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;        <span class="comment">// TODO: rename these operators, their are working on multiindex object in general</span></div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;        <span class="keyword">template</span> &lt;<span class="keyword">class</span> Operator&gt;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        <span class="keyword">struct </span>vecvec&lt;5, Operator&gt; {</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;            <span class="keyword">using</span> in1=gt::accessor&lt;0, enumtype::in, gt::extent&lt;&gt; , 5&gt; ;</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;            <span class="keyword">using</span> in2=gt::accessor&lt;1, enumtype::in, gt::extent&lt;&gt; , 5&gt; ;</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;            <span class="keyword">using</span> out=gt::accessor&lt;2, enumtype::inout, gt::extent&lt;&gt; , 5&gt; ;</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;            <span class="keyword">using</span> arg_list=boost::mpl::vector&lt; in1, in2, out &gt; ;</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;            <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Evaluation&gt;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;            GT_FUNCTION</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;            <span class="keyword">static</span> <span class="keywordtype">void</span> Do(Evaluation <span class="keyword">const</span> &amp; eval, x_interval) {</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;                gt::dimension&lt;4&gt; row;</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;                gt::dimension&lt;5&gt; col;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;                <a class="code" href="a04709.html">uint_t</a> <span class="keyword">const</span> num_rows=eval.template get_storage_dim&lt;3&gt;(in1());</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;                <a class="code" href="a04709.html">uint_t</a> <span class="keyword">const</span> num_cols=eval.template get_storage_dim&lt;4&gt;(in1());</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;                <span class="comment">// Loop over vector elements</span></div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;                <span class="keywordflow">for</span>(<a class="code" href="a04709.html">uint_t</a> i=0;i&lt;num_rows;++i)</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;                    <span class="keywordflow">for</span>(<a class="code" href="a04709.html">uint_t</a> j=0;j&lt;num_cols;++j)  {</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;                        eval(out(row+i,col+j)) = Operator::eval(eval(in1(row+i,col+j)),eval(in2(row+i,col+j)));</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;                }</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;            }</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;        };</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;</div><div class="ttc" id="a04709_html"><div class="ttname"><a href="a04709.html">uint_t</a></div></div>
</div><!-- fragment --><p> This functor plays a role similar to the one used in the previous example, providing a generic implementation for elementwise operations on multidimensional tensor pairs. As for the scalar-tensor case, there are two template parameters: the first one is the number of dimensions of the tensors and the second one the operator to be used for the elementwise operation. These operators must be implemented as functor providing the eval method as in the library provided operators of the following snippet: </p><div class="fragment"><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;        <span class="keyword">struct </span>sum_operator {</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;            GT_FUNCTION</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;            <span class="keyword">static</span> T eval(T <span class="keyword">const</span> &amp; i_a, T <span class="keyword">const</span> &amp; i_b) { <span class="keywordflow">return</span> i_a+i_b; }</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        };</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;        <span class="keyword">struct </span>sub_operator {</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;            GT_FUNCTION</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;            <span class="keyword">static</span> T eval(T <span class="keyword">const</span> &amp; i_a, T <span class="keyword">const</span> &amp; i_b) { <span class="keywordflow">return</span> i_a-i_b; }</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;        };</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;        <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;        <span class="keyword">struct </span>mult_operator {</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;            GT_FUNCTION</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;            <span class="keyword">static</span> T eval(T <span class="keyword">const</span> &amp; i_a, T <span class="keyword">const</span> &amp; i_b) { <span class="keywordflow">return</span> i_a*i_b; }</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;        };</div></div><!-- fragment --><p> The subsequent steps, corresponding to the calls to the ready, steady, run, and  methods, performs the real computation.</p>
<p>Finally we perform a check of the computed results.</p>
<p>The remaining part of this example is focused on the calculation of elementwise vector-vector sum and subtraction and follows the same principles discussed for the multiplication case.</p>
<h1>Full Code </h1>
<div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">  GridTools Libraries</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  Copyright (c) 2016, GridTools Consortium</span></div><div class="line"><span class="comment">  All rights reserved.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  Redistribution and use in source and binary forms, with or without</span></div><div class="line"><span class="comment">  modification, are permitted provided that the following conditions are</span></div><div class="line"><span class="comment">  met:</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  1. Redistributions of source code must retain the above copyright</span></div><div class="line"><span class="comment">  notice, this list of conditions and the following disclaimer.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  2. Redistributions in binary form must reproduce the above copyright</span></div><div class="line"><span class="comment">  notice, this list of conditions and the following disclaimer in the</span></div><div class="line"><span class="comment">  documentation and/or other materials provided with the distribution.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  3. Neither the name of the copyright holder nor the names of its</span></div><div class="line"><span class="comment">  contributors may be used to endorse or promote products derived from</span></div><div class="line"><span class="comment">  this software without specific prior written permission.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span></div><div class="line"><span class="comment">  &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span></div><div class="line"><span class="comment">  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span></div><div class="line"><span class="comment">  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span></div><div class="line"><span class="comment">  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span></div><div class="line"><span class="comment">  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span></div><div class="line"><span class="comment">  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span></div><div class="line"><span class="comment">  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span></div><div class="line"><span class="comment">  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span></div><div class="line"><span class="comment">  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span></div><div class="line"><span class="comment">  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  For information: http://eth-cscs.github.io/gridtools/</span></div><div class="line"><span class="comment">*/</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"><span class="preprocessor">#include &quot;../functors/matvec.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;../galerkin_defs.hpp&quot;</span></div><div class="line"><span class="comment">// TODO: we need an specific header for storage type definition to avoid the include that follows</span></div><div class="line"><span class="preprocessor">#include &quot;../numerics/basis_functions.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;stencil-composition/stencil-composition.hpp&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;stencil-composition/axis.hpp&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> gridtools::interval&lt;gridtools::level&lt;0,-2&gt;, gridtools::level&lt;1,1&gt; &gt; axis;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="a02981.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>() {</div><div class="line"></div><div class="line">    <span class="comment">//[problem_size]</span></div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d1=5;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d2=5;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d3=5;</div><div class="line">    constexpr <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_rows(10);</div><div class="line">    <span class="comment">//[problem_size]</span></div><div class="line"></div><div class="line">    <span class="comment">//[storages]</span></div><div class="line">    <span class="comment">// vector a</span></div><div class="line">    <span class="keyword">using</span> vector_a_storage_info_t=gdl::storage_info&lt; __COUNTER__, gdl::layout_tt&lt;4&gt; &gt;;</div><div class="line">    <span class="keyword">using</span> vector_a_type=gdl::storage_t&lt; vector_a_storage_info_t &gt;;</div><div class="line">    vector_a_storage_info_t v_a_(d1,d2,d3,n_rows);</div><div class="line">    vector_a_type v_a(v_a_, 0.e0, <span class="stringliteral">&quot;v_a&quot;</span>);</div><div class="line">    <span class="comment">// vector b</span></div><div class="line">    <span class="keyword">using</span> vector_b_storage_info_t=gdl::storage_info&lt; __COUNTER__, gdl::layout_tt&lt;4&gt; &gt;;</div><div class="line">    <span class="keyword">using</span> vector_b_type=gdl::storage_t&lt; vector_b_storage_info_t &gt;;</div><div class="line">    vector_b_storage_info_t v_b_(d1,d2,d3,n_rows);</div><div class="line">    vector_b_type v_b(v_b_, 0.e0, <span class="stringliteral">&quot;v_b&quot;</span>);</div><div class="line">    <span class="comment">// vector out</span></div><div class="line">    <span class="keyword">using</span> vector_out_storage_info_t=gdl::storage_info&lt; __COUNTER__, gdl::layout_tt&lt;4&gt; &gt;;</div><div class="line">    <span class="keyword">using</span> vector_out_type=gdl::storage_t&lt; vector_out_storage_info_t &gt;;</div><div class="line">    vector_out_storage_info_t v_out_(d1,d2,d3,n_rows);</div><div class="line">    vector_out_type v_out(v_out_, 0.e0, <span class="stringliteral">&quot;v_out&quot;</span>);</div><div class="line">    <span class="comment">//[storages]</span></div><div class="line"></div><div class="line">    <span class="comment">//[storage_initializazion]</span></div><div class="line">    <span class="keywordflow">for</span> (gdl::uint_t i=0; i&lt;d1; i++)</div><div class="line">        <span class="keywordflow">for</span> (gdl::uint_t j=0; j&lt;d2; j++)</div><div class="line">            <span class="keywordflow">for</span> (gdl::uint_t k=0; k&lt;d3; k++)</div><div class="line">                <span class="keywordflow">for</span> (gdl::uint_t row=0; row&lt;n_rows; ++row) {</div><div class="line">                    v_a(i,j,k,row) = 1.5;</div><div class="line">                    v_b(i,j,k,row) = -1.0;</div><div class="line">                }</div><div class="line">    <span class="comment">//[storage_initializazion]</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//[grid]</span></div><div class="line">    <span class="keyword">auto</span> grid=gridtools::grid&lt;axis&gt;({0, 0, 0, d1-1, d1},</div><div class="line">                                         {0, 0, 0, d2-1, d2});</div><div class="line">    grid.value_list[0] = 0;</div><div class="line">    grid.value_list[1] = d3-1;</div><div class="line">    <span class="comment">//[grid]</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//[domain]</span></div><div class="line">    <span class="keyword">typedef</span> gdl::gt::arg&lt;0,vector_a_type&gt; p_v_a;</div><div class="line">    <span class="keyword">typedef</span> gdl::gt::arg&lt;1,vector_b_type&gt; p_v_b;</div><div class="line">    <span class="keyword">typedef</span> gdl::gt::arg&lt;2,vector_out_type&gt; p_v_out;</div><div class="line">    <span class="keyword">typedef</span> boost::mpl::vector&lt;p_v_a, p_v_b, p_v_out&gt; accessor_list;</div><div class="line">    ::gridtools::aggregator_type&lt;accessor_list&gt; domain(boost::fusion::make_vector(&amp;v_a, &amp;v_b, &amp;v_out));</div><div class="line">    <span class="comment">//[domain]</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//[computation_mult]</span></div><div class="line">    <span class="keyword">auto</span> compute_mult=::gridtools::make_computation&lt;BACKEND&gt;(domain,</div><div class="line">        grid,</div><div class="line">        gridtools::make_multistage(gridtools::enumtype::execute&lt;gridtools::enumtype::forward&gt;(),</div><div class="line">        gridtools::make_stage&lt; <a class="code" href="a04022.html">gdl::functors::vecvec</a>&lt;4,<a class="code" href="a04010.html">gdl::functors::mult_operator&lt;float_t&gt;</a> &gt; &gt;(p_v_a(),p_v_b(),p_v_out())</div><div class="line">                   ));</div><div class="line">    compute_mult-&gt;ready();</div><div class="line">    compute_mult-&gt;steady();</div><div class="line">    compute_mult-&gt;run();</div><div class="line">    compute_mult-&gt;finalize();</div><div class="line">    <span class="comment">//[computation_mult]</span></div><div class="line"></div><div class="line">    <span class="comment">//[check_results_mult]</span></div><div class="line">    <span class="keywordtype">bool</span> success = <span class="keyword">true</span>;</div><div class="line">    <span class="keywordflow">for</span> (gdl::uint_t i=0; i&lt;d1; i++)</div><div class="line">      <span class="keywordflow">for</span> (gdl::uint_t j=0; j&lt;d2; j++)</div><div class="line">        <span class="keywordflow">for</span> (gdl::uint_t k=0; k&lt;d3; k++)</div><div class="line">          <span class="keywordflow">for</span> (gdl::uint_t row=0; row&lt;n_rows; ++row)</div><div class="line">            <span class="keywordflow">if</span>(v_a(i,j,k,row) * v_b(i,j,k,row) != v_out(i,j,k,row)) {</div><div class="line">                std::cout&lt;&lt;<span class="stringliteral">&quot;[&quot;</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>&lt;&lt;j&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>&lt;&lt;k&lt;&lt;<span class="stringliteral">&quot;,&quot;</span>&lt;&lt;row&lt;&lt;<span class="stringliteral">&quot;] : &quot;</span>&lt;&lt;v_a(i,j,k,row)&lt;&lt;<span class="stringliteral">&quot; * &quot;</span>&lt;&lt;v_b(i,j,k,row)&lt;&lt;<span class="stringliteral">&quot; != &quot;</span>&lt;&lt;v_out(i,j,k,row)&lt;&lt;std::endl;</div><div class="line">                success = <span class="keyword">false</span>;</div><div class="line">              <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line">    assert(success);</div><div class="line">    <span class="comment">//[check_results_mult]</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//[computation_sum]</span></div><div class="line">    <span class="keyword">auto</span> compute_sum=::gridtools::make_computation&lt;BACKEND&gt;(domain,</div><div class="line">                                                      grid,</div><div class="line">                                                      gridtools::make_multistage(gridtools::enumtype::execute&lt;gridtools::enumtype::forward&gt;(),</div><div class="line">                                                                                 gridtools::make_stage&lt; <a class="code" href="a04022.html">gdl::functors::vecvec</a>&lt;4,<a class="code" href="a04002.html">gdl::functors::sum_operator&lt;float_t&gt;</a> &gt; &gt;(p_v_a(),p_v_b(),p_v_out())</div><div class="line">                                                                                 )</div><div class="line">                                                     );</div><div class="line">    compute_sum-&gt;ready();</div><div class="line">    compute_sum-&gt;steady();</div><div class="line">    compute_sum-&gt;run();</div><div class="line">    compute_sum-&gt;finalize();</div><div class="line">    <span class="comment">//[computation_sum]</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//[check_results_sum]</span></div><div class="line">    <span class="keywordflow">for</span> (gdl::uint_t i=0; i&lt;d1; i++)</div><div class="line">        <span class="keywordflow">for</span> (gdl::uint_t j=0; j&lt;d2; j++)</div><div class="line">            <span class="keywordflow">for</span> (gdl::uint_t k=0; k&lt;d3; k++)</div><div class="line">                <span class="keywordflow">for</span> (gdl::uint_t row=0; row&lt;n_rows; ++row)</div><div class="line">                    <span class="keywordflow">if</span>(v_a(i,j,k,row) + v_b(i,j,k,row) != v_out(i,j,k,row)) {</div><div class="line">                        success = <span class="keyword">false</span>;</div><div class="line">                        <span class="keywordflow">break</span>;</div><div class="line">                    }</div><div class="line">    assert(success);</div><div class="line">    <span class="comment">//[check_results_sum]</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">//[computation_sub]</span></div><div class="line">    <span class="keyword">auto</span> compute_sub=::gridtools::make_computation&lt;BACKEND&gt;(domain,</div><div class="line">             grid,</div><div class="line">                     gridtools::make_multistage(</div><div class="line">             gridtools::enumtype::execute&lt;gridtools::enumtype::forward&gt;(),</div><div class="line">             gridtools::make_stage&lt; <a class="code" href="a04022.html">gdl::functors::vecvec</a>&lt;4,<a class="code" href="a04006.html">gdl::functors::sub_operator&lt;float_t&gt;</a> &gt; &gt;(p_v_a(),p_v_b(),p_v_out())</div><div class="line">                        ));</div><div class="line">    compute_sub-&gt;ready();</div><div class="line">    compute_sub-&gt;steady();</div><div class="line">    compute_sub-&gt;run();</div><div class="line">    compute_sub-&gt;finalize();</div><div class="line">    <span class="comment">//[computation_sub]</span></div><div class="line"></div><div class="line">    <span class="comment">//[check_results_sub]</span></div><div class="line">    <span class="keywordflow">for</span> (gdl::uint_t i=0; i&lt;d1; i++)</div><div class="line">      <span class="keywordflow">for</span> (gdl::uint_t j=0; j&lt;d2; j++)</div><div class="line">    <span class="keywordflow">for</span> (gdl::uint_t k=0; k&lt;d3; k++)</div><div class="line">      <span class="keywordflow">for</span> (gdl::uint_t row=0; row&lt;n_rows; ++row)</div><div class="line">        <span class="keywordflow">if</span>(v_a(i,j,k,row) - v_b(i,j,k,row) != v_out(i,j,k,row)) {</div><div class="line">          success = <span class="keyword">false</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    assert(success);</div><div class="line">    <span class="comment">//[check_results_sub]</span></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Apr 5 2017 09:06:12 for Galerkin4GT by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.12 </li>
  </ul>
</div>
</body>
</html>
